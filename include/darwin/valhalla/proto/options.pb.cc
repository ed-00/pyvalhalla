// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: options.proto
// Protobuf C++ Version: 5.29.3

#include "options.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace valhalla {

inline constexpr PbfFieldSelector::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : options_{false},
        trip_{false},
        directions_{false},
        status_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PbfFieldSelector::PbfFieldSelector(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PbfFieldSelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbfFieldSelectorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbfFieldSelectorDefaultTypeInternal() {}
  union {
    PbfFieldSelector _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbfFieldSelectorDefaultTypeInternal _PbfFieldSelector_default_instance_;

inline constexpr Contour::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : has_time_{},
        has_color_{},
        has_distance_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Contour::Contour(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ContourDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContourDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContourDefaultTypeInternal() {}
  union {
    Contour _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContourDefaultTypeInternal _Contour_default_instance_;

inline constexpr AvoidEdge::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : has_id_{},
        has_percent_along_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR AvoidEdge::AvoidEdge(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvoidEdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvoidEdgeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvoidEdgeDefaultTypeInternal() {}
  union {
    AvoidEdge _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvoidEdgeDefaultTypeInternal _AvoidEdge_default_instance_;

inline constexpr Ring::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : coords_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Ring::Ring(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RingDefaultTypeInternal() {}
  union {
    Ring _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RingDefaultTypeInternal _Ring_default_instance_;

inline constexpr Costing_Options::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : filter_stop_ids_{},
        filter_operator_ids_{},
        filter_route_ids_{},
        exclude_edges_{},
        filter_stop_action_{static_cast< ::valhalla::FilterAction >(0)},
        filter_operator_action_{static_cast< ::valhalla::FilterAction >(0)},
        filter_route_action_{static_cast< ::valhalla::FilterAction >(0)},
        fixed_speed_{0u},
        axle_count_{0u},
        use_lit_{0},
        disable_hierarchy_pruning_{false},
        has_maneuver_penalty_{},
        has_destination_only_penalty_{},
        has_gate_cost_{},
        has_gate_penalty_{},
        has_toll_booth_cost_{},
        has_toll_booth_penalty_{},
        has_alley_penalty_{},
        has_country_crossing_cost_{},
        has_country_crossing_penalty_{},
        has_ferry_cost_{},
        has_avoid_bad_surfaces_{},
        has_use_ferry_{},
        has_use_highways_{},
        has_use_tolls_{},
        has_use_roads_{},
        has_max_distance_{},
        has_walking_speed_{},
        has_step_penalty_{},
        has_max_grade_{},
        has_max_hiking_difficulty_{},
        has_mode_factor_{},
        has_walkway_factor_{},
        has_sidewalk_factor_{},
        has_alley_factor_{},
        has_driveway_factor_{},
        has_driveway_penalty_{},
        has_transit_start_end_max_distance_{},
        has_transit_transfer_max_distance_{},
        has_transport_type_{},
        has_top_speed_{},
        has_use_hills_{},
        has_use_primary_{},
        has_use_trails_{},
        has_low_class_penalty_{},
        has_hazmat_{},
        has_weight_{},
        has_axle_load_{},
        has_height_{},
        has_width_{},
        has_length_{},
        has_cycling_speed_{},
        has_wheelchair_{},
        has_bicycle_{},
        has_use_bus_{},
        has_use_rail_{},
        has_use_transfers_{},
        has_transfer_cost_{},
        has_transfer_penalty_{},
        has_flow_mask_{},
        has_bike_share_cost_{},
        has_bike_share_penalty_{},
        has_rail_ferry_cost_{},
        has_use_rail_ferry_{},
        has_ignore_restrictions_{},
        has_ignore_oneways_{},
        has_ignore_access_{},
        has_ignore_closures_{},
        has_shortest_{},
        has_service_penalty_{},
        has_use_tracks_{},
        has_use_distance_{},
        has_use_living_streets_{},
        has_service_factor_{},
        has_closure_factor_{},
        has_private_access_penalty_{},
        has_exclude_unpaved_{},
        has_include_hot_{},
        has_include_hov2_{},
        has_include_hov3_{},
        has_exclude_cash_only_tolls_{},
        has_restriction_probability_{},
        has_elevator_penalty_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Costing_Options::Costing_Options(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct Costing_OptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Costing_OptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Costing_OptionsDefaultTypeInternal() {}
  union {
    Costing_Options _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Costing_OptionsDefaultTypeInternal _Costing_Options_default_instance_;

inline constexpr Costing::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : type_{static_cast< ::valhalla::Costing_Type >(0)},
        has_options_{},
        has_name_{},
        has_filter_closures_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Costing::Costing(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CostingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CostingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CostingDefaultTypeInternal() {}
  union {
    Costing _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CostingDefaultTypeInternal _Costing_default_instance_;

inline constexpr Options::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        costings_{},
        locations_{},
        exclude_locations_{},
        sources_{},
        targets_{},
        shape_{},
        contours_{},
        trace_{},
        filter_attributes_{},
        recostings_{},
        exclude_polygons_{},
        expansion_properties_{},
        _expansion_properties_cached_byte_size_{0},
        pbf_field_selector_{nullptr},
        units_{static_cast< ::valhalla::Options_Units >(0)},
        directions_type_{static_cast< ::valhalla::DirectionsType >(0)},
        format_{static_cast< ::valhalla::Options_Format >(0)},
        action_{static_cast< ::valhalla::Options_Action >(0)},
        costing_type_{static_cast< ::valhalla::Costing_Type >(0)},
        date_time_type_{static_cast< ::valhalla::Options_DateTimeType >(0)},
        shape_match_{static_cast< ::valhalla::ShapeMatch >(0)},
        filter_action_{static_cast< ::valhalla::FilterAction >(0)},
        shape_format_{static_cast< ::valhalla::ShapeFormat >(0)},
        reverse_{false},
        has_language_{},
        has_id_{},
        has_jsonp_{},
        has_encoded_polyline_{},
        has_range_{},
        has_verbose_{},
        has_date_time_{},
        has_resample_distance_{},
        has_polygons_{},
        has_denoise_{},
        has_generalize_{},
        has_show_locations_{},
        has_gps_accuracy_{},
        has_search_radius_{},
        has_turn_penalty_factor_{},
        has_breakage_distance_{},
        has_use_timestamps_{},
        has_alternates_{},
        has_interpolation_distance_{},
        has_guidance_views_{},
        has_height_precision_{},
        has_roundabout_exits_{},
        has_linear_references_{},
        has_prioritize_bidirectional_{},
        has_expansion_action_{},
        has_skip_opposites_{},
        has_matrix_locations_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Options::Options(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct OptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OptionsDefaultTypeInternal() {}
  union {
    Options _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptionsDefaultTypeInternal _Options_default_instance_;
}  // namespace valhalla
namespace valhalla {
PROTOBUF_CONSTINIT const uint32_t Costing_Type_internal_data_[] = {
    786432u, 0u, };
bool Costing_Type_IsValid(int value) {
  return 0 <= value && value <= 11;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Costing_Type_strings[12] = {};

static const char Costing_Type_names[] = {
    "auto_"
    "bicycle"
    "bikeshare"
    "bus"
    "motor_scooter"
    "motorcycle"
    "multimodal"
    "none_"
    "pedestrian"
    "taxi"
    "transit"
    "truck"
};

static const ::google::protobuf::internal::EnumEntry Costing_Type_entries[] =
    {
        {{&Costing_Type_names[0], 5}, 10},
        {{&Costing_Type_names[5], 7}, 1},
        {{&Costing_Type_names[12], 9}, 11},
        {{&Costing_Type_names[21], 3}, 2},
        {{&Costing_Type_names[24], 13}, 3},
        {{&Costing_Type_names[37], 10}, 8},
        {{&Costing_Type_names[47], 10}, 4},
        {{&Costing_Type_names[57], 5}, 0},
        {{&Costing_Type_names[62], 10}, 5},
        {{&Costing_Type_names[72], 4}, 9},
        {{&Costing_Type_names[76], 7}, 6},
        {{&Costing_Type_names[83], 5}, 7},
};

static const int Costing_Type_entries_by_number[] = {
    7,  // 0 -> none_
    1,  // 1 -> bicycle
    3,  // 2 -> bus
    4,  // 3 -> motor_scooter
    6,  // 4 -> multimodal
    8,  // 5 -> pedestrian
    10,  // 6 -> transit
    11,  // 7 -> truck
    5,  // 8 -> motorcycle
    9,  // 9 -> taxi
    0,  // 10 -> auto_
    2,  // 11 -> bikeshare
};

const std::string& Costing_Type_Name(Costing_Type value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Costing_Type_entries, Costing_Type_entries_by_number,
          12, Costing_Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Costing_Type_entries, Costing_Type_entries_by_number, 12,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Costing_Type_strings[idx].get();
}

bool Costing_Type_Parse(absl::string_view name, Costing_Type* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Costing_Type_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<Costing_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Costing_Type Costing::none_;
constexpr Costing_Type Costing::bicycle;
constexpr Costing_Type Costing::bus;
constexpr Costing_Type Costing::motor_scooter;
constexpr Costing_Type Costing::multimodal;
constexpr Costing_Type Costing::pedestrian;
constexpr Costing_Type Costing::transit;
constexpr Costing_Type Costing::truck;
constexpr Costing_Type Costing::motorcycle;
constexpr Costing_Type Costing::taxi;
constexpr Costing_Type Costing::auto_;
constexpr Costing_Type Costing::bikeshare;
constexpr Costing_Type Costing::Type_MIN;
constexpr Costing_Type Costing::Type_MAX;
constexpr int Costing::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t Options_Units_internal_data_[] = {
    131072u, 0u, };
bool Options_Units_IsValid(int value) {
  return 0 <= value && value <= 1;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Options_Units_strings[2] = {};

static const char Options_Units_names[] = {
    "kilometers"
    "miles"
};

static const ::google::protobuf::internal::EnumEntry Options_Units_entries[] =
    {
        {{&Options_Units_names[0], 10}, 0},
        {{&Options_Units_names[10], 5}, 1},
};

static const int Options_Units_entries_by_number[] = {
    0,  // 0 -> kilometers
    1,  // 1 -> miles
};

const std::string& Options_Units_Name(Options_Units value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Options_Units_entries, Options_Units_entries_by_number,
          2, Options_Units_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Options_Units_entries, Options_Units_entries_by_number, 2,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Options_Units_strings[idx].get();
}

bool Options_Units_Parse(absl::string_view name, Options_Units* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Options_Units_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Options_Units>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Options_Units Options::kilometers;
constexpr Options_Units Options::miles;
constexpr Options_Units Options::Units_MIN;
constexpr Options_Units Options::Units_MAX;
constexpr int Options::Units_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t Options_Format_internal_data_[] = {
    262144u, 0u, };
bool Options_Format_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Options_Format_strings[4] = {};

static const char Options_Format_names[] = {
    "gpx"
    "json"
    "osrm"
    "pbf"
};

static const ::google::protobuf::internal::EnumEntry Options_Format_entries[] =
    {
        {{&Options_Format_names[0], 3}, 1},
        {{&Options_Format_names[3], 4}, 0},
        {{&Options_Format_names[7], 4}, 2},
        {{&Options_Format_names[11], 3}, 3},
};

static const int Options_Format_entries_by_number[] = {
    1,  // 0 -> json
    0,  // 1 -> gpx
    2,  // 2 -> osrm
    3,  // 3 -> pbf
};

const std::string& Options_Format_Name(Options_Format value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Options_Format_entries, Options_Format_entries_by_number,
          4, Options_Format_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Options_Format_entries, Options_Format_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Options_Format_strings[idx].get();
}

bool Options_Format_Parse(absl::string_view name, Options_Format* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Options_Format_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Options_Format>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Options_Format Options::json;
constexpr Options_Format Options::gpx;
constexpr Options_Format Options::osrm;
constexpr Options_Format Options::pbf;
constexpr Options_Format Options::Format_MIN;
constexpr Options_Format Options::Format_MAX;
constexpr int Options::Format_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t Options_Action_internal_data_[] = {
    851968u, 0u, };
bool Options_Action_IsValid(int value) {
  return 0 <= value && value <= 12;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Options_Action_strings[13] = {};

static const char Options_Action_names[] = {
    "centroid"
    "expansion"
    "height"
    "isochrone"
    "locate"
    "no_action"
    "optimized_route"
    "route"
    "sources_to_targets"
    "status"
    "trace_attributes"
    "trace_route"
    "transit_available"
};

static const ::google::protobuf::internal::EnumEntry Options_Action_entries[] =
    {
        {{&Options_Action_names[0], 8}, 11},
        {{&Options_Action_names[8], 9}, 10},
        {{&Options_Action_names[17], 6}, 8},
        {{&Options_Action_names[23], 9}, 5},
        {{&Options_Action_names[32], 6}, 2},
        {{&Options_Action_names[38], 9}, 0},
        {{&Options_Action_names[47], 15}, 4},
        {{&Options_Action_names[62], 5}, 1},
        {{&Options_Action_names[67], 18}, 3},
        {{&Options_Action_names[85], 6}, 12},
        {{&Options_Action_names[91], 16}, 7},
        {{&Options_Action_names[107], 11}, 6},
        {{&Options_Action_names[118], 17}, 9},
};

static const int Options_Action_entries_by_number[] = {
    5,  // 0 -> no_action
    7,  // 1 -> route
    4,  // 2 -> locate
    8,  // 3 -> sources_to_targets
    6,  // 4 -> optimized_route
    3,  // 5 -> isochrone
    11,  // 6 -> trace_route
    10,  // 7 -> trace_attributes
    2,  // 8 -> height
    12,  // 9 -> transit_available
    1,  // 10 -> expansion
    0,  // 11 -> centroid
    9,  // 12 -> status
};

const std::string& Options_Action_Name(Options_Action value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Options_Action_entries, Options_Action_entries_by_number,
          13, Options_Action_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Options_Action_entries, Options_Action_entries_by_number, 13,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Options_Action_strings[idx].get();
}

bool Options_Action_Parse(absl::string_view name, Options_Action* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Options_Action_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<Options_Action>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Options_Action Options::no_action;
constexpr Options_Action Options::route;
constexpr Options_Action Options::locate;
constexpr Options_Action Options::sources_to_targets;
constexpr Options_Action Options::optimized_route;
constexpr Options_Action Options::isochrone;
constexpr Options_Action Options::trace_route;
constexpr Options_Action Options::trace_attributes;
constexpr Options_Action Options::height;
constexpr Options_Action Options::transit_available;
constexpr Options_Action Options::expansion;
constexpr Options_Action Options::centroid;
constexpr Options_Action Options::status;
constexpr Options_Action Options::Action_MIN;
constexpr Options_Action Options::Action_MAX;
constexpr int Options::Action_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t Options_DateTimeType_internal_data_[] = {
    327680u, 0u, };
bool Options_DateTimeType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Options_DateTimeType_strings[5] = {};

static const char Options_DateTimeType_names[] = {
    "arrive_by"
    "current"
    "depart_at"
    "invariant"
    "no_time"
};

static const ::google::protobuf::internal::EnumEntry Options_DateTimeType_entries[] =
    {
        {{&Options_DateTimeType_names[0], 9}, 3},
        {{&Options_DateTimeType_names[9], 7}, 1},
        {{&Options_DateTimeType_names[16], 9}, 2},
        {{&Options_DateTimeType_names[25], 9}, 4},
        {{&Options_DateTimeType_names[34], 7}, 0},
};

static const int Options_DateTimeType_entries_by_number[] = {
    4,  // 0 -> no_time
    1,  // 1 -> current
    2,  // 2 -> depart_at
    0,  // 3 -> arrive_by
    3,  // 4 -> invariant
};

const std::string& Options_DateTimeType_Name(Options_DateTimeType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Options_DateTimeType_entries, Options_DateTimeType_entries_by_number,
          5, Options_DateTimeType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Options_DateTimeType_entries, Options_DateTimeType_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Options_DateTimeType_strings[idx].get();
}

bool Options_DateTimeType_Parse(absl::string_view name, Options_DateTimeType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Options_DateTimeType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Options_DateTimeType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Options_DateTimeType Options::no_time;
constexpr Options_DateTimeType Options::current;
constexpr Options_DateTimeType Options::depart_at;
constexpr Options_DateTimeType Options::arrive_by;
constexpr Options_DateTimeType Options::invariant;
constexpr Options_DateTimeType Options::DateTimeType_MIN;
constexpr Options_DateTimeType Options::DateTimeType_MAX;
constexpr int Options::DateTimeType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t Options_ExpansionProperties_internal_data_[] = {
    327680u, 0u, };
bool Options_ExpansionProperties_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Options_ExpansionProperties_strings[5] = {};

static const char Options_ExpansionProperties_names[] = {
    "costs"
    "distances"
    "durations"
    "edge_ids"
    "statuses"
};

static const ::google::protobuf::internal::EnumEntry Options_ExpansionProperties_entries[] =
    {
        {{&Options_ExpansionProperties_names[0], 5}, 0},
        {{&Options_ExpansionProperties_names[5], 9}, 2},
        {{&Options_ExpansionProperties_names[14], 9}, 1},
        {{&Options_ExpansionProperties_names[23], 8}, 4},
        {{&Options_ExpansionProperties_names[31], 8}, 3},
};

static const int Options_ExpansionProperties_entries_by_number[] = {
    0,  // 0 -> costs
    2,  // 1 -> durations
    1,  // 2 -> distances
    4,  // 3 -> statuses
    3,  // 4 -> edge_ids
};

const std::string& Options_ExpansionProperties_Name(Options_ExpansionProperties value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Options_ExpansionProperties_entries, Options_ExpansionProperties_entries_by_number,
          5, Options_ExpansionProperties_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Options_ExpansionProperties_entries, Options_ExpansionProperties_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Options_ExpansionProperties_strings[idx].get();
}

bool Options_ExpansionProperties_Parse(absl::string_view name, Options_ExpansionProperties* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Options_ExpansionProperties_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Options_ExpansionProperties>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Options_ExpansionProperties Options::costs;
constexpr Options_ExpansionProperties Options::durations;
constexpr Options_ExpansionProperties Options::distances;
constexpr Options_ExpansionProperties Options::statuses;
constexpr Options_ExpansionProperties Options::edge_ids;
constexpr Options_ExpansionProperties Options::ExpansionProperties_MIN;
constexpr Options_ExpansionProperties Options::ExpansionProperties_MAX;
constexpr int Options::ExpansionProperties_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t ShapeMatch_internal_data_[] = {
    196608u, 0u, };
bool ShapeMatch_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    ShapeMatch_strings[3] = {};

static const char ShapeMatch_names[] = {
    "edge_walk"
    "map_snap"
    "walk_or_snap"
};

static const ::google::protobuf::internal::EnumEntry ShapeMatch_entries[] =
    {
        {{&ShapeMatch_names[0], 9}, 1},
        {{&ShapeMatch_names[9], 8}, 2},
        {{&ShapeMatch_names[17], 12}, 0},
};

static const int ShapeMatch_entries_by_number[] = {
    2,  // 0 -> walk_or_snap
    0,  // 1 -> edge_walk
    1,  // 2 -> map_snap
};

const std::string& ShapeMatch_Name(ShapeMatch value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          ShapeMatch_entries, ShapeMatch_entries_by_number,
          3, ShapeMatch_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      ShapeMatch_entries, ShapeMatch_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : ShapeMatch_strings[idx].get();
}

bool ShapeMatch_Parse(absl::string_view name, ShapeMatch* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      ShapeMatch_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShapeMatch>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t FilterAction_internal_data_[] = {
    196608u, 0u, };
bool FilterAction_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    FilterAction_strings[3] = {};

static const char FilterAction_names[] = {
    "exclude"
    "include"
    "no_action"
};

static const ::google::protobuf::internal::EnumEntry FilterAction_entries[] =
    {
        {{&FilterAction_names[0], 7}, 1},
        {{&FilterAction_names[7], 7}, 2},
        {{&FilterAction_names[14], 9}, 0},
};

static const int FilterAction_entries_by_number[] = {
    2,  // 0 -> no_action
    0,  // 1 -> exclude
    1,  // 2 -> include
};

const std::string& FilterAction_Name(FilterAction value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          FilterAction_entries, FilterAction_entries_by_number,
          3, FilterAction_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      FilterAction_entries, FilterAction_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : FilterAction_strings[idx].get();
}

bool FilterAction_Parse(absl::string_view name, FilterAction* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      FilterAction_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<FilterAction>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t DirectionsType_internal_data_[] = {
    196608u, 0u, };
bool DirectionsType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    DirectionsType_strings[3] = {};

static const char DirectionsType_names[] = {
    "instructions"
    "maneuvers"
    "none"
};

static const ::google::protobuf::internal::EnumEntry DirectionsType_entries[] =
    {
        {{&DirectionsType_names[0], 12}, 0},
        {{&DirectionsType_names[12], 9}, 2},
        {{&DirectionsType_names[21], 4}, 1},
};

static const int DirectionsType_entries_by_number[] = {
    0,  // 0 -> instructions
    2,  // 1 -> none
    1,  // 2 -> maneuvers
};

const std::string& DirectionsType_Name(DirectionsType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          DirectionsType_entries, DirectionsType_entries_by_number,
          3, DirectionsType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      DirectionsType_entries, DirectionsType_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : DirectionsType_strings[idx].get();
}

bool DirectionsType_Parse(absl::string_view name, DirectionsType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      DirectionsType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DirectionsType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t ShapeFormat_internal_data_[] = {
    196608u, 0u, };
bool ShapeFormat_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    ShapeFormat_strings[3] = {};

static const char ShapeFormat_names[] = {
    "geojson"
    "polyline5"
    "polyline6"
};

static const ::google::protobuf::internal::EnumEntry ShapeFormat_entries[] =
    {
        {{&ShapeFormat_names[0], 7}, 2},
        {{&ShapeFormat_names[7], 9}, 1},
        {{&ShapeFormat_names[16], 9}, 0},
};

static const int ShapeFormat_entries_by_number[] = {
    2,  // 0 -> polyline6
    1,  // 1 -> polyline5
    0,  // 2 -> geojson
};

const std::string& ShapeFormat_Name(ShapeFormat value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          ShapeFormat_entries, ShapeFormat_entries_by_number,
          3, ShapeFormat_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      ShapeFormat_entries, ShapeFormat_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : ShapeFormat_strings[idx].get();
}

bool ShapeFormat_Parse(absl::string_view name, ShapeFormat* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      ShapeFormat_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShapeFormat>(int_value);
  }
  return success;
}
// ===================================================================

class Contour::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::valhalla::Contour, _impl_._oneof_case_);
};

Contour::Contour(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Contour)
}
inline PROTOBUF_NDEBUG_INLINE Contour::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Contour& from_msg)
      : has_time_{},
        has_color_{},
        has_distance_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1], from._oneof_case_[2]} {}

Contour::Contour(
    ::google::protobuf::Arena* arena,
    const Contour& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Contour* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (has_time_case()) {
    case HAS_TIME_NOT_SET:
      break;
      case kTime:
        _impl_.has_time_.time_ = from._impl_.has_time_.time_;
        break;
  }
  switch (has_color_case()) {
    case HAS_COLOR_NOT_SET:
      break;
      case kColor:
        new (&_impl_.has_color_.color_) decltype(_impl_.has_color_.color_){arena, from._impl_.has_color_.color_};
        break;
  }
  switch (has_distance_case()) {
    case HAS_DISTANCE_NOT_SET:
      break;
      case kDistance:
        _impl_.has_distance_.distance_ = from._impl_.has_distance_.distance_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.Contour)
}
inline PROTOBUF_NDEBUG_INLINE Contour::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : has_time_{},
        has_color_{},
        has_distance_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void Contour::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
Contour::~Contour() {
  // @@protoc_insertion_point(destructor:valhalla.Contour)
  SharedDtor(*this);
}
inline void Contour::SharedDtor(MessageLite& self) {
  Contour& this_ = static_cast<Contour&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_has_time()) {
    this_.clear_has_time();
  }
  if (this_.has_has_color()) {
    this_.clear_has_color();
  }
  if (this_.has_has_distance()) {
    this_.clear_has_distance();
  }
  this_._impl_.~Impl_();
}

void Contour::clear_has_time() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Contour)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_time_case()) {
    case kTime: {
      // No need to clear
      break;
    }
    case HAS_TIME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_TIME_NOT_SET;
}

void Contour::clear_has_color() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Contour)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_color_case()) {
    case kColor: {
      _impl_.has_color_.color_.Destroy();
      break;
    }
    case HAS_COLOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_COLOR_NOT_SET;
}

void Contour::clear_has_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Contour)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_distance_case()) {
    case kDistance: {
      // No need to clear
      break;
    }
    case HAS_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_DISTANCE_NOT_SET;
}


inline void* Contour::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Contour(arena);
}
constexpr auto Contour::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Contour),
                                            alignof(Contour));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<17> Contour::_class_data_ = {
    {
        &_Contour_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Contour::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Contour>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Contour::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Contour>(), &Contour::ByteSizeLong,
            &Contour::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Contour, _impl_._cached_size_),
        true,
    },
    "valhalla.Contour",
};
const ::google::protobuf::internal::ClassData* Contour::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 3, 0, 30, 2> Contour::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Contour>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // float time = 1;
    {PROTOBUF_FIELD_OFFSET(Contour, _impl_.has_time_.time_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // string color = 2;
    {PROTOBUF_FIELD_OFFSET(Contour, _impl_.has_color_.color_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float distance = 3;
    {PROTOBUF_FIELD_OFFSET(Contour, _impl_.has_distance_.distance_), _Internal::kOneofCaseOffset + 8, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\20\0\5\0\0\0\0\0"
    "valhalla.Contour"
    "color"
  }},
};

PROTOBUF_NOINLINE void Contour::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Contour)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_time();
  clear_has_color();
  clear_has_distance();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Contour::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Contour& this_ = static_cast<const Contour&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Contour::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Contour& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Contour)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // float time = 1;
          if (this_.has_time_case() == kTime) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                1, this_._internal_time(), target);
          }

          // string color = 2;
          if (this_.has_color_case() == kColor) {
            const std::string& _s = this_._internal_color();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Contour.color");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // float distance = 3;
          if (this_.has_distance_case() == kDistance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                3, this_._internal_distance(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Contour)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Contour::ByteSizeLong(const MessageLite& base) {
          const Contour& this_ = static_cast<const Contour&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Contour::ByteSizeLong() const {
          const Contour& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Contour)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          switch (this_.has_time_case()) {
            // float time = 1;
            case kTime: {
              total_size += 5;
              break;
            }
            case HAS_TIME_NOT_SET: {
              break;
            }
          }
          switch (this_.has_color_case()) {
            // string color = 2;
            case kColor: {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_color());
              break;
            }
            case HAS_COLOR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_distance_case()) {
            // float distance = 3;
            case kDistance: {
              total_size += 5;
              break;
            }
            case HAS_DISTANCE_NOT_SET: {
              break;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Contour::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Contour*>(&to_msg);
  auto& from = static_cast<const Contour&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Contour)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_time();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTime: {
        _this->_impl_.has_time_.time_ = from._impl_.has_time_.time_;
        break;
      }
      case HAS_TIME_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_color();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kColor: {
        if (oneof_needs_init) {
          _this->_impl_.has_color_.color_.InitDefault();
        }
        _this->_impl_.has_color_.color_.Set(from._internal_color(), arena);
        break;
      }
      case HAS_COLOR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[2]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[2];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_distance();
      }
      _this->_impl_._oneof_case_[2] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kDistance: {
        _this->_impl_.has_distance_.distance_ = from._impl_.has_distance_.distance_;
        break;
      }
      case HAS_DISTANCE_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Contour::CopyFrom(const Contour& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Contour)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Contour::InternalSwap(Contour* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_time_, other->_impl_.has_time_);
  swap(_impl_.has_color_, other->_impl_.has_color_);
  swap(_impl_.has_distance_, other->_impl_.has_distance_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
}

// ===================================================================

class Ring::_Internal {
 public:
};

void Ring::clear_coords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coords_.Clear();
}
Ring::Ring(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Ring)
}
inline PROTOBUF_NDEBUG_INLINE Ring::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Ring& from_msg)
      : coords_{visibility, arena, from.coords_},
        _cached_size_{0} {}

Ring::Ring(
    ::google::protobuf::Arena* arena,
    const Ring& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Ring* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:valhalla.Ring)
}
inline PROTOBUF_NDEBUG_INLINE Ring::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : coords_{visibility, arena},
        _cached_size_{0} {}

inline void Ring::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
Ring::~Ring() {
  // @@protoc_insertion_point(destructor:valhalla.Ring)
  SharedDtor(*this);
}
inline void Ring::SharedDtor(MessageLite& self) {
  Ring& this_ = static_cast<Ring&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* Ring::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Ring(arena);
}
constexpr auto Ring::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Ring, _impl_.coords_) +
          decltype(Ring::_impl_.coords_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Ring), alignof(Ring), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Ring::PlacementNew_,
                                 sizeof(Ring),
                                 alignof(Ring));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<14> Ring::_class_data_ = {
    {
        &_Ring_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Ring::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Ring>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Ring::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Ring>(), &Ring::ByteSizeLong,
            &Ring::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Ring, _impl_._cached_size_),
        true,
    },
    "valhalla.Ring",
};
const ::google::protobuf::internal::ClassData* Ring::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> Ring::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Ring>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .valhalla.LatLng coords = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Ring, _impl_.coords_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .valhalla.LatLng coords = 1;
    {PROTOBUF_FIELD_OFFSET(Ring, _impl_.coords_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Ring::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Ring)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.coords_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Ring::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Ring& this_ = static_cast<const Ring&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Ring::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Ring& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Ring)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .valhalla.LatLng coords = 1;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_coords_size());
               i < n; i++) {
            const auto& repfield = this_._internal_coords().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Ring)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Ring::ByteSizeLong(const MessageLite& base) {
          const Ring& this_ = static_cast<const Ring&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Ring::ByteSizeLong() const {
          const Ring& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Ring)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .valhalla.LatLng coords = 1;
            {
              total_size += 1UL * this_._internal_coords_size();
              for (const auto& msg : this_._internal_coords()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Ring::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Ring*>(&to_msg);
  auto& from = static_cast<const Ring&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Ring)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_coords()->MergeFrom(
      from._internal_coords());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ring::CopyFrom(const Ring& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Ring)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Ring::InternalSwap(Ring* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.coords_.InternalSwap(&other->_impl_.coords_);
}

// ===================================================================

class PbfFieldSelector::_Internal {
 public:
};

PbfFieldSelector::PbfFieldSelector(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.PbfFieldSelector)
}
PbfFieldSelector::PbfFieldSelector(
    ::google::protobuf::Arena* arena, const PbfFieldSelector& from)
    : PbfFieldSelector(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE PbfFieldSelector::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void PbfFieldSelector::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, options_),
           0,
           offsetof(Impl_, status_) -
               offsetof(Impl_, options_) +
               sizeof(Impl_::status_));
}
PbfFieldSelector::~PbfFieldSelector() {
  // @@protoc_insertion_point(destructor:valhalla.PbfFieldSelector)
  SharedDtor(*this);
}
inline void PbfFieldSelector::SharedDtor(MessageLite& self) {
  PbfFieldSelector& this_ = static_cast<PbfFieldSelector&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PbfFieldSelector::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) PbfFieldSelector(arena);
}
constexpr auto PbfFieldSelector::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PbfFieldSelector),
                                            alignof(PbfFieldSelector));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<26> PbfFieldSelector::_class_data_ = {
    {
        &_PbfFieldSelector_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &PbfFieldSelector::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<PbfFieldSelector>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &PbfFieldSelector::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<PbfFieldSelector>(), &PbfFieldSelector::ByteSizeLong,
            &PbfFieldSelector::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_._cached_size_),
        true,
    },
    "valhalla.PbfFieldSelector",
};
const ::google::protobuf::internal::ClassData* PbfFieldSelector::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> PbfFieldSelector::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::PbfFieldSelector>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool status = 4;
    {::_pbi::TcParser::FastV8S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.status_)}},
    // bool options = 1;
    {::_pbi::TcParser::FastV8S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.options_)}},
    // bool trip = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.trip_)}},
    // bool directions = 3;
    {::_pbi::TcParser::FastV8S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.directions_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bool options = 1;
    {PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.options_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool trip = 2;
    {PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.trip_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool directions = 3;
    {PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.directions_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool status = 4;
    {PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void PbfFieldSelector::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.PbfFieldSelector)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.options_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.options_)) + sizeof(_impl_.status_));
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* PbfFieldSelector::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const PbfFieldSelector& this_ = static_cast<const PbfFieldSelector&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* PbfFieldSelector::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const PbfFieldSelector& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.PbfFieldSelector)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // bool options = 1;
          if (this_._internal_options() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                1, this_._internal_options(), target);
          }

          // bool trip = 2;
          if (this_._internal_trip() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                2, this_._internal_trip(), target);
          }

          // bool directions = 3;
          if (this_._internal_directions() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                3, this_._internal_directions(), target);
          }

          // bool status = 4;
          if (this_._internal_status() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                4, this_._internal_status(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.PbfFieldSelector)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t PbfFieldSelector::ByteSizeLong(const MessageLite& base) {
          const PbfFieldSelector& this_ = static_cast<const PbfFieldSelector&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t PbfFieldSelector::ByteSizeLong() const {
          const PbfFieldSelector& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.PbfFieldSelector)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // bool options = 1;
            if (this_._internal_options() != 0) {
              total_size += 2;
            }
            // bool trip = 2;
            if (this_._internal_trip() != 0) {
              total_size += 2;
            }
            // bool directions = 3;
            if (this_._internal_directions() != 0) {
              total_size += 2;
            }
            // bool status = 4;
            if (this_._internal_status() != 0) {
              total_size += 2;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void PbfFieldSelector::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PbfFieldSelector*>(&to_msg);
  auto& from = static_cast<const PbfFieldSelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.PbfFieldSelector)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_options() != 0) {
    _this->_impl_.options_ = from._impl_.options_;
  }
  if (from._internal_trip() != 0) {
    _this->_impl_.trip_ = from._impl_.trip_;
  }
  if (from._internal_directions() != 0) {
    _this->_impl_.directions_ = from._impl_.directions_;
  }
  if (from._internal_status() != 0) {
    _this->_impl_.status_ = from._impl_.status_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PbfFieldSelector::CopyFrom(const PbfFieldSelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.PbfFieldSelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PbfFieldSelector::InternalSwap(PbfFieldSelector* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.status_)
      + sizeof(PbfFieldSelector::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.options_)>(
          reinterpret_cast<char*>(&_impl_.options_),
          reinterpret_cast<char*>(&other->_impl_.options_));
}

// ===================================================================

class AvoidEdge::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::valhalla::AvoidEdge, _impl_._oneof_case_);
};

AvoidEdge::AvoidEdge(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.AvoidEdge)
}
inline PROTOBUF_NDEBUG_INLINE AvoidEdge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::AvoidEdge& from_msg)
      : has_id_{},
        has_percent_along_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

AvoidEdge::AvoidEdge(
    ::google::protobuf::Arena* arena,
    const AvoidEdge& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvoidEdge* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (has_id_case()) {
    case HAS_ID_NOT_SET:
      break;
      case kId:
        _impl_.has_id_.id_ = from._impl_.has_id_.id_;
        break;
  }
  switch (has_percent_along_case()) {
    case HAS_PERCENT_ALONG_NOT_SET:
      break;
      case kPercentAlong:
        _impl_.has_percent_along_.percent_along_ = from._impl_.has_percent_along_.percent_along_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.AvoidEdge)
}
inline PROTOBUF_NDEBUG_INLINE AvoidEdge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : has_id_{},
        has_percent_along_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void AvoidEdge::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AvoidEdge::~AvoidEdge() {
  // @@protoc_insertion_point(destructor:valhalla.AvoidEdge)
  SharedDtor(*this);
}
inline void AvoidEdge::SharedDtor(MessageLite& self) {
  AvoidEdge& this_ = static_cast<AvoidEdge&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_has_id()) {
    this_.clear_has_id();
  }
  if (this_.has_has_percent_along()) {
    this_.clear_has_percent_along();
  }
  this_._impl_.~Impl_();
}

void AvoidEdge::clear_has_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.AvoidEdge)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_id_case()) {
    case kId: {
      // No need to clear
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_ID_NOT_SET;
}

void AvoidEdge::clear_has_percent_along() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.AvoidEdge)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_percent_along_case()) {
    case kPercentAlong: {
      // No need to clear
      break;
    }
    case HAS_PERCENT_ALONG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_PERCENT_ALONG_NOT_SET;
}


inline void* AvoidEdge::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) AvoidEdge(arena);
}
constexpr auto AvoidEdge::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(AvoidEdge),
                                            alignof(AvoidEdge));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<19> AvoidEdge::_class_data_ = {
    {
        &_AvoidEdge_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &AvoidEdge::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<AvoidEdge>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &AvoidEdge::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<AvoidEdge>(), &AvoidEdge::ByteSizeLong,
            &AvoidEdge::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(AvoidEdge, _impl_._cached_size_),
        true,
    },
    "valhalla.AvoidEdge",
};
const ::google::protobuf::internal::ClassData* AvoidEdge::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 2, 0, 0, 2> AvoidEdge::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::AvoidEdge>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 id = 1;
    {PROTOBUF_FIELD_OFFSET(AvoidEdge, _impl_.has_id_.id_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt64)},
    // float percent_along = 2;
    {PROTOBUF_FIELD_OFFSET(AvoidEdge, _impl_.has_percent_along_.percent_along_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void AvoidEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.AvoidEdge)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_id();
  clear_has_percent_along();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvoidEdge::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvoidEdge& this_ = static_cast<const AvoidEdge&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvoidEdge::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvoidEdge& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.AvoidEdge)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint64 id = 1;
          if (this_.has_id_case() == kId) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
                1, this_._internal_id(), target);
          }

          // float percent_along = 2;
          if (this_.has_percent_along_case() == kPercentAlong) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                2, this_._internal_percent_along(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.AvoidEdge)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvoidEdge::ByteSizeLong(const MessageLite& base) {
          const AvoidEdge& this_ = static_cast<const AvoidEdge&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvoidEdge::ByteSizeLong() const {
          const AvoidEdge& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.AvoidEdge)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          switch (this_.has_id_case()) {
            // uint64 id = 1;
            case kId: {
              total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
                  this_._internal_id());
              break;
            }
            case HAS_ID_NOT_SET: {
              break;
            }
          }
          switch (this_.has_percent_along_case()) {
            // float percent_along = 2;
            case kPercentAlong: {
              total_size += 5;
              break;
            }
            case HAS_PERCENT_ALONG_NOT_SET: {
              break;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void AvoidEdge::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvoidEdge*>(&to_msg);
  auto& from = static_cast<const AvoidEdge&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.AvoidEdge)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_id();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kId: {
        _this->_impl_.has_id_.id_ = from._impl_.has_id_.id_;
        break;
      }
      case HAS_ID_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_percent_along();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kPercentAlong: {
        _this->_impl_.has_percent_along_.percent_along_ = from._impl_.has_percent_along_.percent_along_;
        break;
      }
      case HAS_PERCENT_ALONG_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AvoidEdge::CopyFrom(const AvoidEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.AvoidEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvoidEdge::InternalSwap(AvoidEdge* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_id_, other->_impl_.has_id_);
  swap(_impl_.has_percent_along_, other->_impl_.has_percent_along_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

// ===================================================================

class Costing_Options::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::valhalla::Costing_Options, _impl_._oneof_case_);
};

Costing_Options::Costing_Options(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Costing.Options)
}
inline PROTOBUF_NDEBUG_INLINE Costing_Options::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Costing_Options& from_msg)
      : filter_stop_ids_{visibility, arena, from.filter_stop_ids_},
        filter_operator_ids_{visibility, arena, from.filter_operator_ids_},
        filter_route_ids_{visibility, arena, from.filter_route_ids_},
        exclude_edges_{visibility, arena, from.exclude_edges_},
        has_maneuver_penalty_{},
        has_destination_only_penalty_{},
        has_gate_cost_{},
        has_gate_penalty_{},
        has_toll_booth_cost_{},
        has_toll_booth_penalty_{},
        has_alley_penalty_{},
        has_country_crossing_cost_{},
        has_country_crossing_penalty_{},
        has_ferry_cost_{},
        has_avoid_bad_surfaces_{},
        has_use_ferry_{},
        has_use_highways_{},
        has_use_tolls_{},
        has_use_roads_{},
        has_max_distance_{},
        has_walking_speed_{},
        has_step_penalty_{},
        has_max_grade_{},
        has_max_hiking_difficulty_{},
        has_mode_factor_{},
        has_walkway_factor_{},
        has_sidewalk_factor_{},
        has_alley_factor_{},
        has_driveway_factor_{},
        has_driveway_penalty_{},
        has_transit_start_end_max_distance_{},
        has_transit_transfer_max_distance_{},
        has_transport_type_{},
        has_top_speed_{},
        has_use_hills_{},
        has_use_primary_{},
        has_use_trails_{},
        has_low_class_penalty_{},
        has_hazmat_{},
        has_weight_{},
        has_axle_load_{},
        has_height_{},
        has_width_{},
        has_length_{},
        has_cycling_speed_{},
        has_wheelchair_{},
        has_bicycle_{},
        has_use_bus_{},
        has_use_rail_{},
        has_use_transfers_{},
        has_transfer_cost_{},
        has_transfer_penalty_{},
        has_flow_mask_{},
        has_bike_share_cost_{},
        has_bike_share_penalty_{},
        has_rail_ferry_cost_{},
        has_use_rail_ferry_{},
        has_ignore_restrictions_{},
        has_ignore_oneways_{},
        has_ignore_access_{},
        has_ignore_closures_{},
        has_shortest_{},
        has_service_penalty_{},
        has_use_tracks_{},
        has_use_distance_{},
        has_use_living_streets_{},
        has_service_factor_{},
        has_closure_factor_{},
        has_private_access_penalty_{},
        has_exclude_unpaved_{},
        has_include_hot_{},
        has_include_hov2_{},
        has_include_hov3_{},
        has_exclude_cash_only_tolls_{},
        has_restriction_probability_{},
        has_elevator_penalty_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1], from._oneof_case_[2], from._oneof_case_[3], from._oneof_case_[4], from._oneof_case_[5], from._oneof_case_[6], from._oneof_case_[7], from._oneof_case_[8], from._oneof_case_[9], from._oneof_case_[10], from._oneof_case_[11], from._oneof_case_[12], from._oneof_case_[13], from._oneof_case_[14], from._oneof_case_[15], from._oneof_case_[16], from._oneof_case_[17], from._oneof_case_[18], from._oneof_case_[19], from._oneof_case_[20], from._oneof_case_[21], from._oneof_case_[22], from._oneof_case_[23], from._oneof_case_[24], from._oneof_case_[25], from._oneof_case_[26], from._oneof_case_[27], from._oneof_case_[28], from._oneof_case_[29], from._oneof_case_[30], from._oneof_case_[31], from._oneof_case_[32], from._oneof_case_[33], from._oneof_case_[34], from._oneof_case_[35], from._oneof_case_[36], from._oneof_case_[37], from._oneof_case_[38], from._oneof_case_[39], from._oneof_case_[40], from._oneof_case_[41], from._oneof_case_[42], from._oneof_case_[43], from._oneof_case_[44], from._oneof_case_[45], from._oneof_case_[46], from._oneof_case_[47], from._oneof_case_[48], from._oneof_case_[49], from._oneof_case_[50], from._oneof_case_[51], from._oneof_case_[52], from._oneof_case_[53], from._oneof_case_[54], from._oneof_case_[55], from._oneof_case_[56], from._oneof_case_[57], from._oneof_case_[58], from._oneof_case_[59], from._oneof_case_[60], from._oneof_case_[61], from._oneof_case_[62], from._oneof_case_[63], from._oneof_case_[64], from._oneof_case_[65], from._oneof_case_[66], from._oneof_case_[67], from._oneof_case_[68], from._oneof_case_[69], from._oneof_case_[70], from._oneof_case_[71]} {}

Costing_Options::Costing_Options(
    ::google::protobuf::Arena* arena,
    const Costing_Options& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Costing_Options* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, filter_stop_action_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, filter_stop_action_),
           offsetof(Impl_, disable_hierarchy_pruning_) -
               offsetof(Impl_, filter_stop_action_) +
               sizeof(Impl_::disable_hierarchy_pruning_));
  switch (has_maneuver_penalty_case()) {
    case HAS_MANEUVER_PENALTY_NOT_SET:
      break;
      case kManeuverPenalty:
        _impl_.has_maneuver_penalty_.maneuver_penalty_ = from._impl_.has_maneuver_penalty_.maneuver_penalty_;
        break;
  }
  switch (has_destination_only_penalty_case()) {
    case HAS_DESTINATION_ONLY_PENALTY_NOT_SET:
      break;
      case kDestinationOnlyPenalty:
        _impl_.has_destination_only_penalty_.destination_only_penalty_ = from._impl_.has_destination_only_penalty_.destination_only_penalty_;
        break;
  }
  switch (has_gate_cost_case()) {
    case HAS_GATE_COST_NOT_SET:
      break;
      case kGateCost:
        _impl_.has_gate_cost_.gate_cost_ = from._impl_.has_gate_cost_.gate_cost_;
        break;
  }
  switch (has_gate_penalty_case()) {
    case HAS_GATE_PENALTY_NOT_SET:
      break;
      case kGatePenalty:
        _impl_.has_gate_penalty_.gate_penalty_ = from._impl_.has_gate_penalty_.gate_penalty_;
        break;
  }
  switch (has_toll_booth_cost_case()) {
    case HAS_TOLL_BOOTH_COST_NOT_SET:
      break;
      case kTollBoothCost:
        _impl_.has_toll_booth_cost_.toll_booth_cost_ = from._impl_.has_toll_booth_cost_.toll_booth_cost_;
        break;
  }
  switch (has_toll_booth_penalty_case()) {
    case HAS_TOLL_BOOTH_PENALTY_NOT_SET:
      break;
      case kTollBoothPenalty:
        _impl_.has_toll_booth_penalty_.toll_booth_penalty_ = from._impl_.has_toll_booth_penalty_.toll_booth_penalty_;
        break;
  }
  switch (has_alley_penalty_case()) {
    case HAS_ALLEY_PENALTY_NOT_SET:
      break;
      case kAlleyPenalty:
        _impl_.has_alley_penalty_.alley_penalty_ = from._impl_.has_alley_penalty_.alley_penalty_;
        break;
  }
  switch (has_country_crossing_cost_case()) {
    case HAS_COUNTRY_CROSSING_COST_NOT_SET:
      break;
      case kCountryCrossingCost:
        _impl_.has_country_crossing_cost_.country_crossing_cost_ = from._impl_.has_country_crossing_cost_.country_crossing_cost_;
        break;
  }
  switch (has_country_crossing_penalty_case()) {
    case HAS_COUNTRY_CROSSING_PENALTY_NOT_SET:
      break;
      case kCountryCrossingPenalty:
        _impl_.has_country_crossing_penalty_.country_crossing_penalty_ = from._impl_.has_country_crossing_penalty_.country_crossing_penalty_;
        break;
  }
  switch (has_ferry_cost_case()) {
    case HAS_FERRY_COST_NOT_SET:
      break;
      case kFerryCost:
        _impl_.has_ferry_cost_.ferry_cost_ = from._impl_.has_ferry_cost_.ferry_cost_;
        break;
  }
  switch (has_avoid_bad_surfaces_case()) {
    case HAS_AVOID_BAD_SURFACES_NOT_SET:
      break;
      case kAvoidBadSurfaces:
        _impl_.has_avoid_bad_surfaces_.avoid_bad_surfaces_ = from._impl_.has_avoid_bad_surfaces_.avoid_bad_surfaces_;
        break;
  }
  switch (has_use_ferry_case()) {
    case HAS_USE_FERRY_NOT_SET:
      break;
      case kUseFerry:
        _impl_.has_use_ferry_.use_ferry_ = from._impl_.has_use_ferry_.use_ferry_;
        break;
  }
  switch (has_use_highways_case()) {
    case HAS_USE_HIGHWAYS_NOT_SET:
      break;
      case kUseHighways:
        _impl_.has_use_highways_.use_highways_ = from._impl_.has_use_highways_.use_highways_;
        break;
  }
  switch (has_use_tolls_case()) {
    case HAS_USE_TOLLS_NOT_SET:
      break;
      case kUseTolls:
        _impl_.has_use_tolls_.use_tolls_ = from._impl_.has_use_tolls_.use_tolls_;
        break;
  }
  switch (has_use_roads_case()) {
    case HAS_USE_ROADS_NOT_SET:
      break;
      case kUseRoads:
        _impl_.has_use_roads_.use_roads_ = from._impl_.has_use_roads_.use_roads_;
        break;
  }
  switch (has_max_distance_case()) {
    case HAS_MAX_DISTANCE_NOT_SET:
      break;
      case kMaxDistance:
        _impl_.has_max_distance_.max_distance_ = from._impl_.has_max_distance_.max_distance_;
        break;
  }
  switch (has_walking_speed_case()) {
    case HAS_WALKING_SPEED_NOT_SET:
      break;
      case kWalkingSpeed:
        _impl_.has_walking_speed_.walking_speed_ = from._impl_.has_walking_speed_.walking_speed_;
        break;
  }
  switch (has_step_penalty_case()) {
    case HAS_STEP_PENALTY_NOT_SET:
      break;
      case kStepPenalty:
        _impl_.has_step_penalty_.step_penalty_ = from._impl_.has_step_penalty_.step_penalty_;
        break;
  }
  switch (has_max_grade_case()) {
    case HAS_MAX_GRADE_NOT_SET:
      break;
      case kMaxGrade:
        _impl_.has_max_grade_.max_grade_ = from._impl_.has_max_grade_.max_grade_;
        break;
  }
  switch (has_max_hiking_difficulty_case()) {
    case HAS_MAX_HIKING_DIFFICULTY_NOT_SET:
      break;
      case kMaxHikingDifficulty:
        _impl_.has_max_hiking_difficulty_.max_hiking_difficulty_ = from._impl_.has_max_hiking_difficulty_.max_hiking_difficulty_;
        break;
  }
  switch (has_mode_factor_case()) {
    case HAS_MODE_FACTOR_NOT_SET:
      break;
      case kModeFactor:
        _impl_.has_mode_factor_.mode_factor_ = from._impl_.has_mode_factor_.mode_factor_;
        break;
  }
  switch (has_walkway_factor_case()) {
    case HAS_WALKWAY_FACTOR_NOT_SET:
      break;
      case kWalkwayFactor:
        _impl_.has_walkway_factor_.walkway_factor_ = from._impl_.has_walkway_factor_.walkway_factor_;
        break;
  }
  switch (has_sidewalk_factor_case()) {
    case HAS_SIDEWALK_FACTOR_NOT_SET:
      break;
      case kSidewalkFactor:
        _impl_.has_sidewalk_factor_.sidewalk_factor_ = from._impl_.has_sidewalk_factor_.sidewalk_factor_;
        break;
  }
  switch (has_alley_factor_case()) {
    case HAS_ALLEY_FACTOR_NOT_SET:
      break;
      case kAlleyFactor:
        _impl_.has_alley_factor_.alley_factor_ = from._impl_.has_alley_factor_.alley_factor_;
        break;
  }
  switch (has_driveway_factor_case()) {
    case HAS_DRIVEWAY_FACTOR_NOT_SET:
      break;
      case kDrivewayFactor:
        _impl_.has_driveway_factor_.driveway_factor_ = from._impl_.has_driveway_factor_.driveway_factor_;
        break;
  }
  switch (has_driveway_penalty_case()) {
    case HAS_DRIVEWAY_PENALTY_NOT_SET:
      break;
      case kDrivewayPenalty:
        _impl_.has_driveway_penalty_.driveway_penalty_ = from._impl_.has_driveway_penalty_.driveway_penalty_;
        break;
  }
  switch (has_transit_start_end_max_distance_case()) {
    case HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET:
      break;
      case kTransitStartEndMaxDistance:
        _impl_.has_transit_start_end_max_distance_.transit_start_end_max_distance_ = from._impl_.has_transit_start_end_max_distance_.transit_start_end_max_distance_;
        break;
  }
  switch (has_transit_transfer_max_distance_case()) {
    case HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET:
      break;
      case kTransitTransferMaxDistance:
        _impl_.has_transit_transfer_max_distance_.transit_transfer_max_distance_ = from._impl_.has_transit_transfer_max_distance_.transit_transfer_max_distance_;
        break;
  }
  switch (has_transport_type_case()) {
    case HAS_TRANSPORT_TYPE_NOT_SET:
      break;
      case kTransportType:
        new (&_impl_.has_transport_type_.transport_type_) decltype(_impl_.has_transport_type_.transport_type_){arena, from._impl_.has_transport_type_.transport_type_};
        break;
  }
  switch (has_top_speed_case()) {
    case HAS_TOP_SPEED_NOT_SET:
      break;
      case kTopSpeed:
        _impl_.has_top_speed_.top_speed_ = from._impl_.has_top_speed_.top_speed_;
        break;
  }
  switch (has_use_hills_case()) {
    case HAS_USE_HILLS_NOT_SET:
      break;
      case kUseHills:
        _impl_.has_use_hills_.use_hills_ = from._impl_.has_use_hills_.use_hills_;
        break;
  }
  switch (has_use_primary_case()) {
    case HAS_USE_PRIMARY_NOT_SET:
      break;
      case kUsePrimary:
        _impl_.has_use_primary_.use_primary_ = from._impl_.has_use_primary_.use_primary_;
        break;
  }
  switch (has_use_trails_case()) {
    case HAS_USE_TRAILS_NOT_SET:
      break;
      case kUseTrails:
        _impl_.has_use_trails_.use_trails_ = from._impl_.has_use_trails_.use_trails_;
        break;
  }
  switch (has_low_class_penalty_case()) {
    case HAS_LOW_CLASS_PENALTY_NOT_SET:
      break;
      case kLowClassPenalty:
        _impl_.has_low_class_penalty_.low_class_penalty_ = from._impl_.has_low_class_penalty_.low_class_penalty_;
        break;
  }
  switch (has_hazmat_case()) {
    case HAS_HAZMAT_NOT_SET:
      break;
      case kHazmat:
        _impl_.has_hazmat_.hazmat_ = from._impl_.has_hazmat_.hazmat_;
        break;
  }
  switch (has_weight_case()) {
    case HAS_WEIGHT_NOT_SET:
      break;
      case kWeight:
        _impl_.has_weight_.weight_ = from._impl_.has_weight_.weight_;
        break;
  }
  switch (has_axle_load_case()) {
    case HAS_AXLE_LOAD_NOT_SET:
      break;
      case kAxleLoad:
        _impl_.has_axle_load_.axle_load_ = from._impl_.has_axle_load_.axle_load_;
        break;
  }
  switch (has_height_case()) {
    case HAS_HEIGHT_NOT_SET:
      break;
      case kHeight:
        _impl_.has_height_.height_ = from._impl_.has_height_.height_;
        break;
  }
  switch (has_width_case()) {
    case HAS_WIDTH_NOT_SET:
      break;
      case kWidth:
        _impl_.has_width_.width_ = from._impl_.has_width_.width_;
        break;
  }
  switch (has_length_case()) {
    case HAS_LENGTH_NOT_SET:
      break;
      case kLength:
        _impl_.has_length_.length_ = from._impl_.has_length_.length_;
        break;
  }
  switch (has_cycling_speed_case()) {
    case HAS_CYCLING_SPEED_NOT_SET:
      break;
      case kCyclingSpeed:
        _impl_.has_cycling_speed_.cycling_speed_ = from._impl_.has_cycling_speed_.cycling_speed_;
        break;
  }
  switch (has_wheelchair_case()) {
    case HAS_WHEELCHAIR_NOT_SET:
      break;
      case kWheelchair:
        _impl_.has_wheelchair_.wheelchair_ = from._impl_.has_wheelchair_.wheelchair_;
        break;
  }
  switch (has_bicycle_case()) {
    case HAS_BICYCLE_NOT_SET:
      break;
      case kBicycle:
        _impl_.has_bicycle_.bicycle_ = from._impl_.has_bicycle_.bicycle_;
        break;
  }
  switch (has_use_bus_case()) {
    case HAS_USE_BUS_NOT_SET:
      break;
      case kUseBus:
        _impl_.has_use_bus_.use_bus_ = from._impl_.has_use_bus_.use_bus_;
        break;
  }
  switch (has_use_rail_case()) {
    case HAS_USE_RAIL_NOT_SET:
      break;
      case kUseRail:
        _impl_.has_use_rail_.use_rail_ = from._impl_.has_use_rail_.use_rail_;
        break;
  }
  switch (has_use_transfers_case()) {
    case HAS_USE_TRANSFERS_NOT_SET:
      break;
      case kUseTransfers:
        _impl_.has_use_transfers_.use_transfers_ = from._impl_.has_use_transfers_.use_transfers_;
        break;
  }
  switch (has_transfer_cost_case()) {
    case HAS_TRANSFER_COST_NOT_SET:
      break;
      case kTransferCost:
        _impl_.has_transfer_cost_.transfer_cost_ = from._impl_.has_transfer_cost_.transfer_cost_;
        break;
  }
  switch (has_transfer_penalty_case()) {
    case HAS_TRANSFER_PENALTY_NOT_SET:
      break;
      case kTransferPenalty:
        _impl_.has_transfer_penalty_.transfer_penalty_ = from._impl_.has_transfer_penalty_.transfer_penalty_;
        break;
  }
  switch (has_flow_mask_case()) {
    case HAS_FLOW_MASK_NOT_SET:
      break;
      case kFlowMask:
        _impl_.has_flow_mask_.flow_mask_ = from._impl_.has_flow_mask_.flow_mask_;
        break;
  }
  switch (has_bike_share_cost_case()) {
    case HAS_BIKE_SHARE_COST_NOT_SET:
      break;
      case kBikeShareCost:
        _impl_.has_bike_share_cost_.bike_share_cost_ = from._impl_.has_bike_share_cost_.bike_share_cost_;
        break;
  }
  switch (has_bike_share_penalty_case()) {
    case HAS_BIKE_SHARE_PENALTY_NOT_SET:
      break;
      case kBikeSharePenalty:
        _impl_.has_bike_share_penalty_.bike_share_penalty_ = from._impl_.has_bike_share_penalty_.bike_share_penalty_;
        break;
  }
  switch (has_rail_ferry_cost_case()) {
    case HAS_RAIL_FERRY_COST_NOT_SET:
      break;
      case kRailFerryCost:
        _impl_.has_rail_ferry_cost_.rail_ferry_cost_ = from._impl_.has_rail_ferry_cost_.rail_ferry_cost_;
        break;
  }
  switch (has_use_rail_ferry_case()) {
    case HAS_USE_RAIL_FERRY_NOT_SET:
      break;
      case kUseRailFerry:
        _impl_.has_use_rail_ferry_.use_rail_ferry_ = from._impl_.has_use_rail_ferry_.use_rail_ferry_;
        break;
  }
  switch (has_ignore_restrictions_case()) {
    case HAS_IGNORE_RESTRICTIONS_NOT_SET:
      break;
      case kIgnoreRestrictions:
        _impl_.has_ignore_restrictions_.ignore_restrictions_ = from._impl_.has_ignore_restrictions_.ignore_restrictions_;
        break;
  }
  switch (has_ignore_oneways_case()) {
    case HAS_IGNORE_ONEWAYS_NOT_SET:
      break;
      case kIgnoreOneways:
        _impl_.has_ignore_oneways_.ignore_oneways_ = from._impl_.has_ignore_oneways_.ignore_oneways_;
        break;
  }
  switch (has_ignore_access_case()) {
    case HAS_IGNORE_ACCESS_NOT_SET:
      break;
      case kIgnoreAccess:
        _impl_.has_ignore_access_.ignore_access_ = from._impl_.has_ignore_access_.ignore_access_;
        break;
  }
  switch (has_ignore_closures_case()) {
    case HAS_IGNORE_CLOSURES_NOT_SET:
      break;
      case kIgnoreClosures:
        _impl_.has_ignore_closures_.ignore_closures_ = from._impl_.has_ignore_closures_.ignore_closures_;
        break;
  }
  switch (has_shortest_case()) {
    case HAS_SHORTEST_NOT_SET:
      break;
      case kShortest:
        _impl_.has_shortest_.shortest_ = from._impl_.has_shortest_.shortest_;
        break;
  }
  switch (has_service_penalty_case()) {
    case HAS_SERVICE_PENALTY_NOT_SET:
      break;
      case kServicePenalty:
        _impl_.has_service_penalty_.service_penalty_ = from._impl_.has_service_penalty_.service_penalty_;
        break;
  }
  switch (has_use_tracks_case()) {
    case HAS_USE_TRACKS_NOT_SET:
      break;
      case kUseTracks:
        _impl_.has_use_tracks_.use_tracks_ = from._impl_.has_use_tracks_.use_tracks_;
        break;
  }
  switch (has_use_distance_case()) {
    case HAS_USE_DISTANCE_NOT_SET:
      break;
      case kUseDistance:
        _impl_.has_use_distance_.use_distance_ = from._impl_.has_use_distance_.use_distance_;
        break;
  }
  switch (has_use_living_streets_case()) {
    case HAS_USE_LIVING_STREETS_NOT_SET:
      break;
      case kUseLivingStreets:
        _impl_.has_use_living_streets_.use_living_streets_ = from._impl_.has_use_living_streets_.use_living_streets_;
        break;
  }
  switch (has_service_factor_case()) {
    case HAS_SERVICE_FACTOR_NOT_SET:
      break;
      case kServiceFactor:
        _impl_.has_service_factor_.service_factor_ = from._impl_.has_service_factor_.service_factor_;
        break;
  }
  switch (has_closure_factor_case()) {
    case HAS_CLOSURE_FACTOR_NOT_SET:
      break;
      case kClosureFactor:
        _impl_.has_closure_factor_.closure_factor_ = from._impl_.has_closure_factor_.closure_factor_;
        break;
  }
  switch (has_private_access_penalty_case()) {
    case HAS_PRIVATE_ACCESS_PENALTY_NOT_SET:
      break;
      case kPrivateAccessPenalty:
        _impl_.has_private_access_penalty_.private_access_penalty_ = from._impl_.has_private_access_penalty_.private_access_penalty_;
        break;
  }
  switch (has_exclude_unpaved_case()) {
    case HAS_EXCLUDE_UNPAVED_NOT_SET:
      break;
      case kExcludeUnpaved:
        _impl_.has_exclude_unpaved_.exclude_unpaved_ = from._impl_.has_exclude_unpaved_.exclude_unpaved_;
        break;
  }
  switch (has_include_hot_case()) {
    case HAS_INCLUDE_HOT_NOT_SET:
      break;
      case kIncludeHot:
        _impl_.has_include_hot_.include_hot_ = from._impl_.has_include_hot_.include_hot_;
        break;
  }
  switch (has_include_hov2_case()) {
    case HAS_INCLUDE_HOV2_NOT_SET:
      break;
      case kIncludeHov2:
        _impl_.has_include_hov2_.include_hov2_ = from._impl_.has_include_hov2_.include_hov2_;
        break;
  }
  switch (has_include_hov3_case()) {
    case HAS_INCLUDE_HOV3_NOT_SET:
      break;
      case kIncludeHov3:
        _impl_.has_include_hov3_.include_hov3_ = from._impl_.has_include_hov3_.include_hov3_;
        break;
  }
  switch (has_exclude_cash_only_tolls_case()) {
    case HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET:
      break;
      case kExcludeCashOnlyTolls:
        _impl_.has_exclude_cash_only_tolls_.exclude_cash_only_tolls_ = from._impl_.has_exclude_cash_only_tolls_.exclude_cash_only_tolls_;
        break;
  }
  switch (has_restriction_probability_case()) {
    case HAS_RESTRICTION_PROBABILITY_NOT_SET:
      break;
      case kRestrictionProbability:
        _impl_.has_restriction_probability_.restriction_probability_ = from._impl_.has_restriction_probability_.restriction_probability_;
        break;
  }
  switch (has_elevator_penalty_case()) {
    case HAS_ELEVATOR_PENALTY_NOT_SET:
      break;
      case kElevatorPenalty:
        _impl_.has_elevator_penalty_.elevator_penalty_ = from._impl_.has_elevator_penalty_.elevator_penalty_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.Costing.Options)
}
inline PROTOBUF_NDEBUG_INLINE Costing_Options::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : filter_stop_ids_{visibility, arena},
        filter_operator_ids_{visibility, arena},
        filter_route_ids_{visibility, arena},
        exclude_edges_{visibility, arena},
        has_maneuver_penalty_{},
        has_destination_only_penalty_{},
        has_gate_cost_{},
        has_gate_penalty_{},
        has_toll_booth_cost_{},
        has_toll_booth_penalty_{},
        has_alley_penalty_{},
        has_country_crossing_cost_{},
        has_country_crossing_penalty_{},
        has_ferry_cost_{},
        has_avoid_bad_surfaces_{},
        has_use_ferry_{},
        has_use_highways_{},
        has_use_tolls_{},
        has_use_roads_{},
        has_max_distance_{},
        has_walking_speed_{},
        has_step_penalty_{},
        has_max_grade_{},
        has_max_hiking_difficulty_{},
        has_mode_factor_{},
        has_walkway_factor_{},
        has_sidewalk_factor_{},
        has_alley_factor_{},
        has_driveway_factor_{},
        has_driveway_penalty_{},
        has_transit_start_end_max_distance_{},
        has_transit_transfer_max_distance_{},
        has_transport_type_{},
        has_top_speed_{},
        has_use_hills_{},
        has_use_primary_{},
        has_use_trails_{},
        has_low_class_penalty_{},
        has_hazmat_{},
        has_weight_{},
        has_axle_load_{},
        has_height_{},
        has_width_{},
        has_length_{},
        has_cycling_speed_{},
        has_wheelchair_{},
        has_bicycle_{},
        has_use_bus_{},
        has_use_rail_{},
        has_use_transfers_{},
        has_transfer_cost_{},
        has_transfer_penalty_{},
        has_flow_mask_{},
        has_bike_share_cost_{},
        has_bike_share_penalty_{},
        has_rail_ferry_cost_{},
        has_use_rail_ferry_{},
        has_ignore_restrictions_{},
        has_ignore_oneways_{},
        has_ignore_access_{},
        has_ignore_closures_{},
        has_shortest_{},
        has_service_penalty_{},
        has_use_tracks_{},
        has_use_distance_{},
        has_use_living_streets_{},
        has_service_factor_{},
        has_closure_factor_{},
        has_private_access_penalty_{},
        has_exclude_unpaved_{},
        has_include_hot_{},
        has_include_hov2_{},
        has_include_hov3_{},
        has_exclude_cash_only_tolls_{},
        has_restriction_probability_{},
        has_elevator_penalty_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void Costing_Options::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, filter_stop_action_),
           0,
           offsetof(Impl_, disable_hierarchy_pruning_) -
               offsetof(Impl_, filter_stop_action_) +
               sizeof(Impl_::disable_hierarchy_pruning_));
}
Costing_Options::~Costing_Options() {
  // @@protoc_insertion_point(destructor:valhalla.Costing.Options)
  SharedDtor(*this);
}
inline void Costing_Options::SharedDtor(MessageLite& self) {
  Costing_Options& this_ = static_cast<Costing_Options&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_has_maneuver_penalty()) {
    this_.clear_has_maneuver_penalty();
  }
  if (this_.has_has_destination_only_penalty()) {
    this_.clear_has_destination_only_penalty();
  }
  if (this_.has_has_gate_cost()) {
    this_.clear_has_gate_cost();
  }
  if (this_.has_has_gate_penalty()) {
    this_.clear_has_gate_penalty();
  }
  if (this_.has_has_toll_booth_cost()) {
    this_.clear_has_toll_booth_cost();
  }
  if (this_.has_has_toll_booth_penalty()) {
    this_.clear_has_toll_booth_penalty();
  }
  if (this_.has_has_alley_penalty()) {
    this_.clear_has_alley_penalty();
  }
  if (this_.has_has_country_crossing_cost()) {
    this_.clear_has_country_crossing_cost();
  }
  if (this_.has_has_country_crossing_penalty()) {
    this_.clear_has_country_crossing_penalty();
  }
  if (this_.has_has_ferry_cost()) {
    this_.clear_has_ferry_cost();
  }
  if (this_.has_has_avoid_bad_surfaces()) {
    this_.clear_has_avoid_bad_surfaces();
  }
  if (this_.has_has_use_ferry()) {
    this_.clear_has_use_ferry();
  }
  if (this_.has_has_use_highways()) {
    this_.clear_has_use_highways();
  }
  if (this_.has_has_use_tolls()) {
    this_.clear_has_use_tolls();
  }
  if (this_.has_has_use_roads()) {
    this_.clear_has_use_roads();
  }
  if (this_.has_has_max_distance()) {
    this_.clear_has_max_distance();
  }
  if (this_.has_has_walking_speed()) {
    this_.clear_has_walking_speed();
  }
  if (this_.has_has_step_penalty()) {
    this_.clear_has_step_penalty();
  }
  if (this_.has_has_max_grade()) {
    this_.clear_has_max_grade();
  }
  if (this_.has_has_max_hiking_difficulty()) {
    this_.clear_has_max_hiking_difficulty();
  }
  if (this_.has_has_mode_factor()) {
    this_.clear_has_mode_factor();
  }
  if (this_.has_has_walkway_factor()) {
    this_.clear_has_walkway_factor();
  }
  if (this_.has_has_sidewalk_factor()) {
    this_.clear_has_sidewalk_factor();
  }
  if (this_.has_has_alley_factor()) {
    this_.clear_has_alley_factor();
  }
  if (this_.has_has_driveway_factor()) {
    this_.clear_has_driveway_factor();
  }
  if (this_.has_has_driveway_penalty()) {
    this_.clear_has_driveway_penalty();
  }
  if (this_.has_has_transit_start_end_max_distance()) {
    this_.clear_has_transit_start_end_max_distance();
  }
  if (this_.has_has_transit_transfer_max_distance()) {
    this_.clear_has_transit_transfer_max_distance();
  }
  if (this_.has_has_transport_type()) {
    this_.clear_has_transport_type();
  }
  if (this_.has_has_top_speed()) {
    this_.clear_has_top_speed();
  }
  if (this_.has_has_use_hills()) {
    this_.clear_has_use_hills();
  }
  if (this_.has_has_use_primary()) {
    this_.clear_has_use_primary();
  }
  if (this_.has_has_use_trails()) {
    this_.clear_has_use_trails();
  }
  if (this_.has_has_low_class_penalty()) {
    this_.clear_has_low_class_penalty();
  }
  if (this_.has_has_hazmat()) {
    this_.clear_has_hazmat();
  }
  if (this_.has_has_weight()) {
    this_.clear_has_weight();
  }
  if (this_.has_has_axle_load()) {
    this_.clear_has_axle_load();
  }
  if (this_.has_has_height()) {
    this_.clear_has_height();
  }
  if (this_.has_has_width()) {
    this_.clear_has_width();
  }
  if (this_.has_has_length()) {
    this_.clear_has_length();
  }
  if (this_.has_has_cycling_speed()) {
    this_.clear_has_cycling_speed();
  }
  if (this_.has_has_wheelchair()) {
    this_.clear_has_wheelchair();
  }
  if (this_.has_has_bicycle()) {
    this_.clear_has_bicycle();
  }
  if (this_.has_has_use_bus()) {
    this_.clear_has_use_bus();
  }
  if (this_.has_has_use_rail()) {
    this_.clear_has_use_rail();
  }
  if (this_.has_has_use_transfers()) {
    this_.clear_has_use_transfers();
  }
  if (this_.has_has_transfer_cost()) {
    this_.clear_has_transfer_cost();
  }
  if (this_.has_has_transfer_penalty()) {
    this_.clear_has_transfer_penalty();
  }
  if (this_.has_has_flow_mask()) {
    this_.clear_has_flow_mask();
  }
  if (this_.has_has_bike_share_cost()) {
    this_.clear_has_bike_share_cost();
  }
  if (this_.has_has_bike_share_penalty()) {
    this_.clear_has_bike_share_penalty();
  }
  if (this_.has_has_rail_ferry_cost()) {
    this_.clear_has_rail_ferry_cost();
  }
  if (this_.has_has_use_rail_ferry()) {
    this_.clear_has_use_rail_ferry();
  }
  if (this_.has_has_ignore_restrictions()) {
    this_.clear_has_ignore_restrictions();
  }
  if (this_.has_has_ignore_oneways()) {
    this_.clear_has_ignore_oneways();
  }
  if (this_.has_has_ignore_access()) {
    this_.clear_has_ignore_access();
  }
  if (this_.has_has_ignore_closures()) {
    this_.clear_has_ignore_closures();
  }
  if (this_.has_has_shortest()) {
    this_.clear_has_shortest();
  }
  if (this_.has_has_service_penalty()) {
    this_.clear_has_service_penalty();
  }
  if (this_.has_has_use_tracks()) {
    this_.clear_has_use_tracks();
  }
  if (this_.has_has_use_distance()) {
    this_.clear_has_use_distance();
  }
  if (this_.has_has_use_living_streets()) {
    this_.clear_has_use_living_streets();
  }
  if (this_.has_has_service_factor()) {
    this_.clear_has_service_factor();
  }
  if (this_.has_has_closure_factor()) {
    this_.clear_has_closure_factor();
  }
  if (this_.has_has_private_access_penalty()) {
    this_.clear_has_private_access_penalty();
  }
  if (this_.has_has_exclude_unpaved()) {
    this_.clear_has_exclude_unpaved();
  }
  if (this_.has_has_include_hot()) {
    this_.clear_has_include_hot();
  }
  if (this_.has_has_include_hov2()) {
    this_.clear_has_include_hov2();
  }
  if (this_.has_has_include_hov3()) {
    this_.clear_has_include_hov3();
  }
  if (this_.has_has_exclude_cash_only_tolls()) {
    this_.clear_has_exclude_cash_only_tolls();
  }
  if (this_.has_has_restriction_probability()) {
    this_.clear_has_restriction_probability();
  }
  if (this_.has_has_elevator_penalty()) {
    this_.clear_has_elevator_penalty();
  }
  this_._impl_.~Impl_();
}

void Costing_Options::clear_has_maneuver_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_maneuver_penalty_case()) {
    case kManeuverPenalty: {
      // No need to clear
      break;
    }
    case HAS_MANEUVER_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_MANEUVER_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_destination_only_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_destination_only_penalty_case()) {
    case kDestinationOnlyPenalty: {
      // No need to clear
      break;
    }
    case HAS_DESTINATION_ONLY_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_DESTINATION_ONLY_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_gate_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_gate_cost_case()) {
    case kGateCost: {
      // No need to clear
      break;
    }
    case HAS_GATE_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_GATE_COST_NOT_SET;
}

void Costing_Options::clear_has_gate_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_gate_penalty_case()) {
    case kGatePenalty: {
      // No need to clear
      break;
    }
    case HAS_GATE_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_GATE_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_toll_booth_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_toll_booth_cost_case()) {
    case kTollBoothCost: {
      // No need to clear
      break;
    }
    case HAS_TOLL_BOOTH_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = HAS_TOLL_BOOTH_COST_NOT_SET;
}

void Costing_Options::clear_has_toll_booth_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_toll_booth_penalty_case()) {
    case kTollBoothPenalty: {
      // No need to clear
      break;
    }
    case HAS_TOLL_BOOTH_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[5] = HAS_TOLL_BOOTH_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_alley_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_alley_penalty_case()) {
    case kAlleyPenalty: {
      // No need to clear
      break;
    }
    case HAS_ALLEY_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[6] = HAS_ALLEY_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_country_crossing_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_country_crossing_cost_case()) {
    case kCountryCrossingCost: {
      // No need to clear
      break;
    }
    case HAS_COUNTRY_CROSSING_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[7] = HAS_COUNTRY_CROSSING_COST_NOT_SET;
}

void Costing_Options::clear_has_country_crossing_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_country_crossing_penalty_case()) {
    case kCountryCrossingPenalty: {
      // No need to clear
      break;
    }
    case HAS_COUNTRY_CROSSING_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[8] = HAS_COUNTRY_CROSSING_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_ferry_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_ferry_cost_case()) {
    case kFerryCost: {
      // No need to clear
      break;
    }
    case HAS_FERRY_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[9] = HAS_FERRY_COST_NOT_SET;
}

void Costing_Options::clear_has_avoid_bad_surfaces() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_avoid_bad_surfaces_case()) {
    case kAvoidBadSurfaces: {
      // No need to clear
      break;
    }
    case HAS_AVOID_BAD_SURFACES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[10] = HAS_AVOID_BAD_SURFACES_NOT_SET;
}

void Costing_Options::clear_has_use_ferry() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_ferry_case()) {
    case kUseFerry: {
      // No need to clear
      break;
    }
    case HAS_USE_FERRY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[11] = HAS_USE_FERRY_NOT_SET;
}

void Costing_Options::clear_has_use_highways() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_highways_case()) {
    case kUseHighways: {
      // No need to clear
      break;
    }
    case HAS_USE_HIGHWAYS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[12] = HAS_USE_HIGHWAYS_NOT_SET;
}

void Costing_Options::clear_has_use_tolls() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_tolls_case()) {
    case kUseTolls: {
      // No need to clear
      break;
    }
    case HAS_USE_TOLLS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[13] = HAS_USE_TOLLS_NOT_SET;
}

void Costing_Options::clear_has_use_roads() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_roads_case()) {
    case kUseRoads: {
      // No need to clear
      break;
    }
    case HAS_USE_ROADS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[14] = HAS_USE_ROADS_NOT_SET;
}

void Costing_Options::clear_has_max_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_max_distance_case()) {
    case kMaxDistance: {
      // No need to clear
      break;
    }
    case HAS_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[15] = HAS_MAX_DISTANCE_NOT_SET;
}

void Costing_Options::clear_has_walking_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_walking_speed_case()) {
    case kWalkingSpeed: {
      // No need to clear
      break;
    }
    case HAS_WALKING_SPEED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[16] = HAS_WALKING_SPEED_NOT_SET;
}

void Costing_Options::clear_has_step_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_step_penalty_case()) {
    case kStepPenalty: {
      // No need to clear
      break;
    }
    case HAS_STEP_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[17] = HAS_STEP_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_max_grade() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_max_grade_case()) {
    case kMaxGrade: {
      // No need to clear
      break;
    }
    case HAS_MAX_GRADE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[18] = HAS_MAX_GRADE_NOT_SET;
}

void Costing_Options::clear_has_max_hiking_difficulty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_max_hiking_difficulty_case()) {
    case kMaxHikingDifficulty: {
      // No need to clear
      break;
    }
    case HAS_MAX_HIKING_DIFFICULTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[19] = HAS_MAX_HIKING_DIFFICULTY_NOT_SET;
}

void Costing_Options::clear_has_mode_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_mode_factor_case()) {
    case kModeFactor: {
      // No need to clear
      break;
    }
    case HAS_MODE_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[20] = HAS_MODE_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_walkway_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_walkway_factor_case()) {
    case kWalkwayFactor: {
      // No need to clear
      break;
    }
    case HAS_WALKWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[21] = HAS_WALKWAY_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_sidewalk_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_sidewalk_factor_case()) {
    case kSidewalkFactor: {
      // No need to clear
      break;
    }
    case HAS_SIDEWALK_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[22] = HAS_SIDEWALK_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_alley_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_alley_factor_case()) {
    case kAlleyFactor: {
      // No need to clear
      break;
    }
    case HAS_ALLEY_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[23] = HAS_ALLEY_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_driveway_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_driveway_factor_case()) {
    case kDrivewayFactor: {
      // No need to clear
      break;
    }
    case HAS_DRIVEWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[24] = HAS_DRIVEWAY_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_driveway_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_driveway_penalty_case()) {
    case kDrivewayPenalty: {
      // No need to clear
      break;
    }
    case HAS_DRIVEWAY_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[25] = HAS_DRIVEWAY_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_transit_start_end_max_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_transit_start_end_max_distance_case()) {
    case kTransitStartEndMaxDistance: {
      // No need to clear
      break;
    }
    case HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[26] = HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET;
}

void Costing_Options::clear_has_transit_transfer_max_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_transit_transfer_max_distance_case()) {
    case kTransitTransferMaxDistance: {
      // No need to clear
      break;
    }
    case HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[27] = HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET;
}

void Costing_Options::clear_has_transport_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_transport_type_case()) {
    case kTransportType: {
      _impl_.has_transport_type_.transport_type_.Destroy();
      break;
    }
    case HAS_TRANSPORT_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[28] = HAS_TRANSPORT_TYPE_NOT_SET;
}

void Costing_Options::clear_has_top_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_top_speed_case()) {
    case kTopSpeed: {
      // No need to clear
      break;
    }
    case HAS_TOP_SPEED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[29] = HAS_TOP_SPEED_NOT_SET;
}

void Costing_Options::clear_has_use_hills() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_hills_case()) {
    case kUseHills: {
      // No need to clear
      break;
    }
    case HAS_USE_HILLS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[30] = HAS_USE_HILLS_NOT_SET;
}

void Costing_Options::clear_has_use_primary() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_primary_case()) {
    case kUsePrimary: {
      // No need to clear
      break;
    }
    case HAS_USE_PRIMARY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[31] = HAS_USE_PRIMARY_NOT_SET;
}

void Costing_Options::clear_has_use_trails() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_trails_case()) {
    case kUseTrails: {
      // No need to clear
      break;
    }
    case HAS_USE_TRAILS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[32] = HAS_USE_TRAILS_NOT_SET;
}

void Costing_Options::clear_has_low_class_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_low_class_penalty_case()) {
    case kLowClassPenalty: {
      // No need to clear
      break;
    }
    case HAS_LOW_CLASS_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[33] = HAS_LOW_CLASS_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_hazmat() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_hazmat_case()) {
    case kHazmat: {
      // No need to clear
      break;
    }
    case HAS_HAZMAT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[34] = HAS_HAZMAT_NOT_SET;
}

void Costing_Options::clear_has_weight() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_weight_case()) {
    case kWeight: {
      // No need to clear
      break;
    }
    case HAS_WEIGHT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[35] = HAS_WEIGHT_NOT_SET;
}

void Costing_Options::clear_has_axle_load() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_axle_load_case()) {
    case kAxleLoad: {
      // No need to clear
      break;
    }
    case HAS_AXLE_LOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[36] = HAS_AXLE_LOAD_NOT_SET;
}

void Costing_Options::clear_has_height() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_height_case()) {
    case kHeight: {
      // No need to clear
      break;
    }
    case HAS_HEIGHT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[37] = HAS_HEIGHT_NOT_SET;
}

void Costing_Options::clear_has_width() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_width_case()) {
    case kWidth: {
      // No need to clear
      break;
    }
    case HAS_WIDTH_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[38] = HAS_WIDTH_NOT_SET;
}

void Costing_Options::clear_has_length() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_length_case()) {
    case kLength: {
      // No need to clear
      break;
    }
    case HAS_LENGTH_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[39] = HAS_LENGTH_NOT_SET;
}

void Costing_Options::clear_has_cycling_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_cycling_speed_case()) {
    case kCyclingSpeed: {
      // No need to clear
      break;
    }
    case HAS_CYCLING_SPEED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[40] = HAS_CYCLING_SPEED_NOT_SET;
}

void Costing_Options::clear_has_wheelchair() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_wheelchair_case()) {
    case kWheelchair: {
      // No need to clear
      break;
    }
    case HAS_WHEELCHAIR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[41] = HAS_WHEELCHAIR_NOT_SET;
}

void Costing_Options::clear_has_bicycle() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_bicycle_case()) {
    case kBicycle: {
      // No need to clear
      break;
    }
    case HAS_BICYCLE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[42] = HAS_BICYCLE_NOT_SET;
}

void Costing_Options::clear_has_use_bus() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_bus_case()) {
    case kUseBus: {
      // No need to clear
      break;
    }
    case HAS_USE_BUS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[43] = HAS_USE_BUS_NOT_SET;
}

void Costing_Options::clear_has_use_rail() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_rail_case()) {
    case kUseRail: {
      // No need to clear
      break;
    }
    case HAS_USE_RAIL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[44] = HAS_USE_RAIL_NOT_SET;
}

void Costing_Options::clear_has_use_transfers() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_transfers_case()) {
    case kUseTransfers: {
      // No need to clear
      break;
    }
    case HAS_USE_TRANSFERS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[45] = HAS_USE_TRANSFERS_NOT_SET;
}

void Costing_Options::clear_has_transfer_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_transfer_cost_case()) {
    case kTransferCost: {
      // No need to clear
      break;
    }
    case HAS_TRANSFER_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[46] = HAS_TRANSFER_COST_NOT_SET;
}

void Costing_Options::clear_has_transfer_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_transfer_penalty_case()) {
    case kTransferPenalty: {
      // No need to clear
      break;
    }
    case HAS_TRANSFER_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[47] = HAS_TRANSFER_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_flow_mask() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_flow_mask_case()) {
    case kFlowMask: {
      // No need to clear
      break;
    }
    case HAS_FLOW_MASK_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[48] = HAS_FLOW_MASK_NOT_SET;
}

void Costing_Options::clear_has_bike_share_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_bike_share_cost_case()) {
    case kBikeShareCost: {
      // No need to clear
      break;
    }
    case HAS_BIKE_SHARE_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[49] = HAS_BIKE_SHARE_COST_NOT_SET;
}

void Costing_Options::clear_has_bike_share_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_bike_share_penalty_case()) {
    case kBikeSharePenalty: {
      // No need to clear
      break;
    }
    case HAS_BIKE_SHARE_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[50] = HAS_BIKE_SHARE_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_rail_ferry_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_rail_ferry_cost_case()) {
    case kRailFerryCost: {
      // No need to clear
      break;
    }
    case HAS_RAIL_FERRY_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[51] = HAS_RAIL_FERRY_COST_NOT_SET;
}

void Costing_Options::clear_has_use_rail_ferry() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_rail_ferry_case()) {
    case kUseRailFerry: {
      // No need to clear
      break;
    }
    case HAS_USE_RAIL_FERRY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[52] = HAS_USE_RAIL_FERRY_NOT_SET;
}

void Costing_Options::clear_has_ignore_restrictions() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_ignore_restrictions_case()) {
    case kIgnoreRestrictions: {
      // No need to clear
      break;
    }
    case HAS_IGNORE_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[53] = HAS_IGNORE_RESTRICTIONS_NOT_SET;
}

void Costing_Options::clear_has_ignore_oneways() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_ignore_oneways_case()) {
    case kIgnoreOneways: {
      // No need to clear
      break;
    }
    case HAS_IGNORE_ONEWAYS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[54] = HAS_IGNORE_ONEWAYS_NOT_SET;
}

void Costing_Options::clear_has_ignore_access() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_ignore_access_case()) {
    case kIgnoreAccess: {
      // No need to clear
      break;
    }
    case HAS_IGNORE_ACCESS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[55] = HAS_IGNORE_ACCESS_NOT_SET;
}

void Costing_Options::clear_has_ignore_closures() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_ignore_closures_case()) {
    case kIgnoreClosures: {
      // No need to clear
      break;
    }
    case HAS_IGNORE_CLOSURES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[56] = HAS_IGNORE_CLOSURES_NOT_SET;
}

void Costing_Options::clear_has_shortest() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_shortest_case()) {
    case kShortest: {
      // No need to clear
      break;
    }
    case HAS_SHORTEST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[57] = HAS_SHORTEST_NOT_SET;
}

void Costing_Options::clear_has_service_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_service_penalty_case()) {
    case kServicePenalty: {
      // No need to clear
      break;
    }
    case HAS_SERVICE_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[58] = HAS_SERVICE_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_use_tracks() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_tracks_case()) {
    case kUseTracks: {
      // No need to clear
      break;
    }
    case HAS_USE_TRACKS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[59] = HAS_USE_TRACKS_NOT_SET;
}

void Costing_Options::clear_has_use_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_distance_case()) {
    case kUseDistance: {
      // No need to clear
      break;
    }
    case HAS_USE_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[60] = HAS_USE_DISTANCE_NOT_SET;
}

void Costing_Options::clear_has_use_living_streets() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_living_streets_case()) {
    case kUseLivingStreets: {
      // No need to clear
      break;
    }
    case HAS_USE_LIVING_STREETS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[61] = HAS_USE_LIVING_STREETS_NOT_SET;
}

void Costing_Options::clear_has_service_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_service_factor_case()) {
    case kServiceFactor: {
      // No need to clear
      break;
    }
    case HAS_SERVICE_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[62] = HAS_SERVICE_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_closure_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_closure_factor_case()) {
    case kClosureFactor: {
      // No need to clear
      break;
    }
    case HAS_CLOSURE_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[63] = HAS_CLOSURE_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_private_access_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_private_access_penalty_case()) {
    case kPrivateAccessPenalty: {
      // No need to clear
      break;
    }
    case HAS_PRIVATE_ACCESS_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[64] = HAS_PRIVATE_ACCESS_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_exclude_unpaved() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_exclude_unpaved_case()) {
    case kExcludeUnpaved: {
      // No need to clear
      break;
    }
    case HAS_EXCLUDE_UNPAVED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[65] = HAS_EXCLUDE_UNPAVED_NOT_SET;
}

void Costing_Options::clear_has_include_hot() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_include_hot_case()) {
    case kIncludeHot: {
      // No need to clear
      break;
    }
    case HAS_INCLUDE_HOT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[66] = HAS_INCLUDE_HOT_NOT_SET;
}

void Costing_Options::clear_has_include_hov2() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_include_hov2_case()) {
    case kIncludeHov2: {
      // No need to clear
      break;
    }
    case HAS_INCLUDE_HOV2_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[67] = HAS_INCLUDE_HOV2_NOT_SET;
}

void Costing_Options::clear_has_include_hov3() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_include_hov3_case()) {
    case kIncludeHov3: {
      // No need to clear
      break;
    }
    case HAS_INCLUDE_HOV3_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[68] = HAS_INCLUDE_HOV3_NOT_SET;
}

void Costing_Options::clear_has_exclude_cash_only_tolls() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_exclude_cash_only_tolls_case()) {
    case kExcludeCashOnlyTolls: {
      // No need to clear
      break;
    }
    case HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[69] = HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET;
}

void Costing_Options::clear_has_restriction_probability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_restriction_probability_case()) {
    case kRestrictionProbability: {
      // No need to clear
      break;
    }
    case HAS_RESTRICTION_PROBABILITY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[70] = HAS_RESTRICTION_PROBABILITY_NOT_SET;
}

void Costing_Options::clear_has_elevator_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_elevator_penalty_case()) {
    case kElevatorPenalty: {
      // No need to clear
      break;
    }
    case HAS_ELEVATOR_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[71] = HAS_ELEVATOR_PENALTY_NOT_SET;
}


inline void* Costing_Options::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Costing_Options(arena);
}
constexpr auto Costing_Options::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_stop_ids_) +
          decltype(Costing_Options::_impl_.filter_stop_ids_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_operator_ids_) +
          decltype(Costing_Options::_impl_.filter_operator_ids_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_route_ids_) +
          decltype(Costing_Options::_impl_.filter_route_ids_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.exclude_edges_) +
          decltype(Costing_Options::_impl_.exclude_edges_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Costing_Options), alignof(Costing_Options), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Costing_Options::PlacementNew_,
                                 sizeof(Costing_Options),
                                 alignof(Costing_Options));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<25> Costing_Options::_class_data_ = {
    {
        &_Costing_Options_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Costing_Options::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Costing_Options>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Costing_Options::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Costing_Options>(), &Costing_Options::ByteSizeLong,
            &Costing_Options::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_._cached_size_),
        true,
    },
    "valhalla.Costing.Options",
};
const ::google::protobuf::internal::ClassData* Costing_Options::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 83, 1, 177, 13> Costing_Options::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    83, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    83,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Costing_Options>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 fixed_speed = 80;
    {::_pbi::TcParser::FastV32S2,
     {1408, 63, 0, PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.fixed_speed_)}},
    // .valhalla.FilterAction filter_stop_action = 49;
    {::_pbi::TcParser::FastV32S2,
     {904, 63, 0, PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_stop_action_)}},
    // repeated string filter_stop_ids = 50;
    {::_pbi::TcParser::FastUR2,
     {914, 63, 0, PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_stop_ids_)}},
    // .valhalla.FilterAction filter_operator_action = 51;
    {::_pbi::TcParser::FastV32S2,
     {920, 63, 0, PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_operator_action_)}},
    // repeated string filter_operator_ids = 52;
    {::_pbi::TcParser::FastUR2,
     {930, 63, 0, PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_operator_ids_)}},
    // .valhalla.FilterAction filter_route_action = 53;
    {::_pbi::TcParser::FastV32S2,
     {936, 63, 0, PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_route_action_)}},
    // repeated string filter_route_ids = 54;
    {::_pbi::TcParser::FastUR2,
     {946, 63, 0, PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_route_ids_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .valhalla.AvoidEdge exclude_edges = 78;
    {::_pbi::TcParser::FastMtR2,
     {1266, 63, 0, PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.exclude_edges_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    33, 0, 4,
    0, 32, 0, 48, 0, 64, 65528, 80,
    65535, 65535
  }}, {{
    // float maneuver_penalty = 1;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_maneuver_penalty_.maneuver_penalty_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float destination_only_penalty = 2;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_destination_only_penalty_.destination_only_penalty_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float gate_cost = 3;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_gate_cost_.gate_cost_), _Internal::kOneofCaseOffset + 8, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float gate_penalty = 4;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_gate_penalty_.gate_penalty_), _Internal::kOneofCaseOffset + 12, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float toll_booth_cost = 5;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_toll_booth_cost_.toll_booth_cost_), _Internal::kOneofCaseOffset + 16, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float toll_booth_penalty = 6;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_toll_booth_penalty_.toll_booth_penalty_), _Internal::kOneofCaseOffset + 20, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float alley_penalty = 7;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_alley_penalty_.alley_penalty_), _Internal::kOneofCaseOffset + 24, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float country_crossing_cost = 8;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_country_crossing_cost_.country_crossing_cost_), _Internal::kOneofCaseOffset + 28, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float country_crossing_penalty = 9;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_country_crossing_penalty_.country_crossing_penalty_), _Internal::kOneofCaseOffset + 32, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float ferry_cost = 10;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_ferry_cost_.ferry_cost_), _Internal::kOneofCaseOffset + 36, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float avoid_bad_surfaces = 11;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_avoid_bad_surfaces_.avoid_bad_surfaces_), _Internal::kOneofCaseOffset + 40, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_ferry = 12;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_ferry_.use_ferry_), _Internal::kOneofCaseOffset + 44, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_highways = 13;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_highways_.use_highways_), _Internal::kOneofCaseOffset + 48, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_tolls = 14;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_tolls_.use_tolls_), _Internal::kOneofCaseOffset + 52, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_roads = 15;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_roads_.use_roads_), _Internal::kOneofCaseOffset + 56, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // uint32 max_distance = 16;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_max_distance_.max_distance_), _Internal::kOneofCaseOffset + 60, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // float walking_speed = 17;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_walking_speed_.walking_speed_), _Internal::kOneofCaseOffset + 64, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float step_penalty = 18;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_step_penalty_.step_penalty_), _Internal::kOneofCaseOffset + 68, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // uint32 max_grade = 19;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_max_grade_.max_grade_), _Internal::kOneofCaseOffset + 72, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 max_hiking_difficulty = 20;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_max_hiking_difficulty_.max_hiking_difficulty_), _Internal::kOneofCaseOffset + 76, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // float mode_factor = 21;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_mode_factor_.mode_factor_), _Internal::kOneofCaseOffset + 80, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float walkway_factor = 22;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_walkway_factor_.walkway_factor_), _Internal::kOneofCaseOffset + 84, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float sidewalk_factor = 23;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_sidewalk_factor_.sidewalk_factor_), _Internal::kOneofCaseOffset + 88, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float alley_factor = 24;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_alley_factor_.alley_factor_), _Internal::kOneofCaseOffset + 92, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float driveway_factor = 25;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_driveway_factor_.driveway_factor_), _Internal::kOneofCaseOffset + 96, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float driveway_penalty = 26;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_driveway_penalty_.driveway_penalty_), _Internal::kOneofCaseOffset + 100, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // uint32 transit_start_end_max_distance = 27;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_transit_start_end_max_distance_.transit_start_end_max_distance_), _Internal::kOneofCaseOffset + 104, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 transit_transfer_max_distance = 28;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_transit_transfer_max_distance_.transit_transfer_max_distance_), _Internal::kOneofCaseOffset + 108, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // string transport_type = 29;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_transport_type_.transport_type_), _Internal::kOneofCaseOffset + 112, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float top_speed = 30;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_top_speed_.top_speed_), _Internal::kOneofCaseOffset + 116, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_hills = 31;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_hills_.use_hills_), _Internal::kOneofCaseOffset + 120, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_primary = 32;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_primary_.use_primary_), _Internal::kOneofCaseOffset + 124, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_trails = 33;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_trails_.use_trails_), _Internal::kOneofCaseOffset + 128, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float low_class_penalty = 34;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_low_class_penalty_.low_class_penalty_), _Internal::kOneofCaseOffset + 132, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // bool hazmat = 35;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_hazmat_.hazmat_), _Internal::kOneofCaseOffset + 136, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // float weight = 36;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_weight_.weight_), _Internal::kOneofCaseOffset + 140, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float axle_load = 37;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_axle_load_.axle_load_), _Internal::kOneofCaseOffset + 144, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float height = 38;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_height_.height_), _Internal::kOneofCaseOffset + 148, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float width = 39;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_width_.width_), _Internal::kOneofCaseOffset + 152, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float length = 40;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_length_.length_), _Internal::kOneofCaseOffset + 156, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float cycling_speed = 41;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_cycling_speed_.cycling_speed_), _Internal::kOneofCaseOffset + 160, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // bool wheelchair = 42;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_wheelchair_.wheelchair_), _Internal::kOneofCaseOffset + 164, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool bicycle = 43;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_bicycle_.bicycle_), _Internal::kOneofCaseOffset + 168, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // float use_bus = 44;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_bus_.use_bus_), _Internal::kOneofCaseOffset + 172, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_rail = 45;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_rail_.use_rail_), _Internal::kOneofCaseOffset + 176, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_transfers = 46;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_transfers_.use_transfers_), _Internal::kOneofCaseOffset + 180, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float transfer_cost = 47;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_transfer_cost_.transfer_cost_), _Internal::kOneofCaseOffset + 184, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float transfer_penalty = 48;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_transfer_penalty_.transfer_penalty_), _Internal::kOneofCaseOffset + 188, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // .valhalla.FilterAction filter_stop_action = 49;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_stop_action_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // repeated string filter_stop_ids = 50;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_stop_ids_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // .valhalla.FilterAction filter_operator_action = 51;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_operator_action_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // repeated string filter_operator_ids = 52;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_operator_ids_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // .valhalla.FilterAction filter_route_action = 53;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_route_action_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // repeated string filter_route_ids = 54;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_route_ids_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // uint32 flow_mask = 55;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_flow_mask_.flow_mask_), _Internal::kOneofCaseOffset + 192, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // float bike_share_cost = 56;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_bike_share_cost_.bike_share_cost_), _Internal::kOneofCaseOffset + 196, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float bike_share_penalty = 57;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_bike_share_penalty_.bike_share_penalty_), _Internal::kOneofCaseOffset + 200, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float rail_ferry_cost = 58;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_rail_ferry_cost_.rail_ferry_cost_), _Internal::kOneofCaseOffset + 204, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_rail_ferry = 59;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_rail_ferry_.use_rail_ferry_), _Internal::kOneofCaseOffset + 208, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // bool ignore_restrictions = 60;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_ignore_restrictions_.ignore_restrictions_), _Internal::kOneofCaseOffset + 212, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ignore_oneways = 61;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_ignore_oneways_.ignore_oneways_), _Internal::kOneofCaseOffset + 216, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ignore_access = 62;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_ignore_access_.ignore_access_), _Internal::kOneofCaseOffset + 220, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ignore_closures = 63;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_ignore_closures_.ignore_closures_), _Internal::kOneofCaseOffset + 224, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool shortest = 64;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_shortest_.shortest_), _Internal::kOneofCaseOffset + 228, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // float service_penalty = 65;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_service_penalty_.service_penalty_), _Internal::kOneofCaseOffset + 232, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_tracks = 66;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_tracks_.use_tracks_), _Internal::kOneofCaseOffset + 236, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_distance = 67;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_distance_.use_distance_), _Internal::kOneofCaseOffset + 240, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float use_living_streets = 68;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_use_living_streets_.use_living_streets_), _Internal::kOneofCaseOffset + 244, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float service_factor = 69;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_service_factor_.service_factor_), _Internal::kOneofCaseOffset + 248, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float closure_factor = 70;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_closure_factor_.closure_factor_), _Internal::kOneofCaseOffset + 252, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float private_access_penalty = 71;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_private_access_penalty_.private_access_penalty_), _Internal::kOneofCaseOffset + 256, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // bool exclude_unpaved = 72;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_exclude_unpaved_.exclude_unpaved_), _Internal::kOneofCaseOffset + 260, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool include_hot = 73;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_include_hot_.include_hot_), _Internal::kOneofCaseOffset + 264, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool include_hov2 = 74;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_include_hov2_.include_hov2_), _Internal::kOneofCaseOffset + 268, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool include_hov3 = 75;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_include_hov3_.include_hov3_), _Internal::kOneofCaseOffset + 272, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool exclude_cash_only_tolls = 76;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_exclude_cash_only_tolls_.exclude_cash_only_tolls_), _Internal::kOneofCaseOffset + 276, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // uint32 restriction_probability = 77;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_restriction_probability_.restriction_probability_), _Internal::kOneofCaseOffset + 280, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // repeated .valhalla.AvoidEdge exclude_edges = 78;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.exclude_edges_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // float elevator_penalty = 79;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.has_elevator_penalty_.elevator_penalty_), _Internal::kOneofCaseOffset + 284, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // uint32 fixed_speed = 80;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.fixed_speed_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 axle_count = 81;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.axle_count_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // float use_lit = 82;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.use_lit_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // bool disable_hierarchy_pruning = 83;
    {PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.disable_hierarchy_pruning_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::AvoidEdge>()},
  }}, {{
    "\30\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\17\0\23\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "valhalla.Costing.Options"
    "transport_type"
    "filter_stop_ids"
    "filter_operator_ids"
    "filter_route_ids"
  }},
};

PROTOBUF_NOINLINE void Costing_Options::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Costing.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.filter_stop_ids_.Clear();
  _impl_.filter_operator_ids_.Clear();
  _impl_.filter_route_ids_.Clear();
  _impl_.exclude_edges_.Clear();
  ::memset(&_impl_.filter_stop_action_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.disable_hierarchy_pruning_) -
      reinterpret_cast<char*>(&_impl_.filter_stop_action_)) + sizeof(_impl_.disable_hierarchy_pruning_));
  clear_has_maneuver_penalty();
  clear_has_destination_only_penalty();
  clear_has_gate_cost();
  clear_has_gate_penalty();
  clear_has_toll_booth_cost();
  clear_has_toll_booth_penalty();
  clear_has_alley_penalty();
  clear_has_country_crossing_cost();
  clear_has_country_crossing_penalty();
  clear_has_ferry_cost();
  clear_has_avoid_bad_surfaces();
  clear_has_use_ferry();
  clear_has_use_highways();
  clear_has_use_tolls();
  clear_has_use_roads();
  clear_has_max_distance();
  clear_has_walking_speed();
  clear_has_step_penalty();
  clear_has_max_grade();
  clear_has_max_hiking_difficulty();
  clear_has_mode_factor();
  clear_has_walkway_factor();
  clear_has_sidewalk_factor();
  clear_has_alley_factor();
  clear_has_driveway_factor();
  clear_has_driveway_penalty();
  clear_has_transit_start_end_max_distance();
  clear_has_transit_transfer_max_distance();
  clear_has_transport_type();
  clear_has_top_speed();
  clear_has_use_hills();
  clear_has_use_primary();
  clear_has_use_trails();
  clear_has_low_class_penalty();
  clear_has_hazmat();
  clear_has_weight();
  clear_has_axle_load();
  clear_has_height();
  clear_has_width();
  clear_has_length();
  clear_has_cycling_speed();
  clear_has_wheelchair();
  clear_has_bicycle();
  clear_has_use_bus();
  clear_has_use_rail();
  clear_has_use_transfers();
  clear_has_transfer_cost();
  clear_has_transfer_penalty();
  clear_has_flow_mask();
  clear_has_bike_share_cost();
  clear_has_bike_share_penalty();
  clear_has_rail_ferry_cost();
  clear_has_use_rail_ferry();
  clear_has_ignore_restrictions();
  clear_has_ignore_oneways();
  clear_has_ignore_access();
  clear_has_ignore_closures();
  clear_has_shortest();
  clear_has_service_penalty();
  clear_has_use_tracks();
  clear_has_use_distance();
  clear_has_use_living_streets();
  clear_has_service_factor();
  clear_has_closure_factor();
  clear_has_private_access_penalty();
  clear_has_exclude_unpaved();
  clear_has_include_hot();
  clear_has_include_hov2();
  clear_has_include_hov3();
  clear_has_exclude_cash_only_tolls();
  clear_has_restriction_probability();
  clear_has_elevator_penalty();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Costing_Options::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Costing_Options& this_ = static_cast<const Costing_Options&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Costing_Options::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Costing_Options& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Costing.Options)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // float maneuver_penalty = 1;
          if (this_.has_maneuver_penalty_case() == kManeuverPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                1, this_._internal_maneuver_penalty(), target);
          }

          // float destination_only_penalty = 2;
          if (this_.has_destination_only_penalty_case() == kDestinationOnlyPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                2, this_._internal_destination_only_penalty(), target);
          }

          // float gate_cost = 3;
          if (this_.has_gate_cost_case() == kGateCost) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                3, this_._internal_gate_cost(), target);
          }

          // float gate_penalty = 4;
          if (this_.has_gate_penalty_case() == kGatePenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                4, this_._internal_gate_penalty(), target);
          }

          // float toll_booth_cost = 5;
          if (this_.has_toll_booth_cost_case() == kTollBoothCost) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                5, this_._internal_toll_booth_cost(), target);
          }

          // float toll_booth_penalty = 6;
          if (this_.has_toll_booth_penalty_case() == kTollBoothPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                6, this_._internal_toll_booth_penalty(), target);
          }

          // float alley_penalty = 7;
          if (this_.has_alley_penalty_case() == kAlleyPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                7, this_._internal_alley_penalty(), target);
          }

          // float country_crossing_cost = 8;
          if (this_.has_country_crossing_cost_case() == kCountryCrossingCost) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                8, this_._internal_country_crossing_cost(), target);
          }

          // float country_crossing_penalty = 9;
          if (this_.has_country_crossing_penalty_case() == kCountryCrossingPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                9, this_._internal_country_crossing_penalty(), target);
          }

          // float ferry_cost = 10;
          if (this_.has_ferry_cost_case() == kFerryCost) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                10, this_._internal_ferry_cost(), target);
          }

          // float avoid_bad_surfaces = 11;
          if (this_.has_avoid_bad_surfaces_case() == kAvoidBadSurfaces) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                11, this_._internal_avoid_bad_surfaces(), target);
          }

          // float use_ferry = 12;
          if (this_.has_use_ferry_case() == kUseFerry) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                12, this_._internal_use_ferry(), target);
          }

          // float use_highways = 13;
          if (this_.has_use_highways_case() == kUseHighways) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                13, this_._internal_use_highways(), target);
          }

          // float use_tolls = 14;
          if (this_.has_use_tolls_case() == kUseTolls) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                14, this_._internal_use_tolls(), target);
          }

          // float use_roads = 15;
          if (this_.has_use_roads_case() == kUseRoads) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                15, this_._internal_use_roads(), target);
          }

          // uint32 max_distance = 16;
          if (this_.has_max_distance_case() == kMaxDistance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                16, this_._internal_max_distance(), target);
          }

          // float walking_speed = 17;
          if (this_.has_walking_speed_case() == kWalkingSpeed) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                17, this_._internal_walking_speed(), target);
          }

          // float step_penalty = 18;
          if (this_.has_step_penalty_case() == kStepPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                18, this_._internal_step_penalty(), target);
          }

          // uint32 max_grade = 19;
          if (this_.has_max_grade_case() == kMaxGrade) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                19, this_._internal_max_grade(), target);
          }

          // uint32 max_hiking_difficulty = 20;
          if (this_.has_max_hiking_difficulty_case() == kMaxHikingDifficulty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                20, this_._internal_max_hiking_difficulty(), target);
          }

          // float mode_factor = 21;
          if (this_.has_mode_factor_case() == kModeFactor) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                21, this_._internal_mode_factor(), target);
          }

          // float walkway_factor = 22;
          if (this_.has_walkway_factor_case() == kWalkwayFactor) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                22, this_._internal_walkway_factor(), target);
          }

          // float sidewalk_factor = 23;
          if (this_.has_sidewalk_factor_case() == kSidewalkFactor) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                23, this_._internal_sidewalk_factor(), target);
          }

          // float alley_factor = 24;
          if (this_.has_alley_factor_case() == kAlleyFactor) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                24, this_._internal_alley_factor(), target);
          }

          // float driveway_factor = 25;
          if (this_.has_driveway_factor_case() == kDrivewayFactor) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                25, this_._internal_driveway_factor(), target);
          }

          // float driveway_penalty = 26;
          if (this_.has_driveway_penalty_case() == kDrivewayPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                26, this_._internal_driveway_penalty(), target);
          }

          // uint32 transit_start_end_max_distance = 27;
          if (this_.has_transit_start_end_max_distance_case() == kTransitStartEndMaxDistance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                27, this_._internal_transit_start_end_max_distance(), target);
          }

          // uint32 transit_transfer_max_distance = 28;
          if (this_.has_transit_transfer_max_distance_case() == kTransitTransferMaxDistance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                28, this_._internal_transit_transfer_max_distance(), target);
          }

          // string transport_type = 29;
          if (this_.has_transport_type_case() == kTransportType) {
            const std::string& _s = this_._internal_transport_type();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Costing.Options.transport_type");
            target = stream->WriteStringMaybeAliased(29, _s, target);
          }

          // float top_speed = 30;
          if (this_.has_top_speed_case() == kTopSpeed) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                30, this_._internal_top_speed(), target);
          }

          // float use_hills = 31;
          if (this_.has_use_hills_case() == kUseHills) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                31, this_._internal_use_hills(), target);
          }

          // float use_primary = 32;
          if (this_.has_use_primary_case() == kUsePrimary) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                32, this_._internal_use_primary(), target);
          }

          // float use_trails = 33;
          if (this_.has_use_trails_case() == kUseTrails) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                33, this_._internal_use_trails(), target);
          }

          // float low_class_penalty = 34;
          if (this_.has_low_class_penalty_case() == kLowClassPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                34, this_._internal_low_class_penalty(), target);
          }

          // bool hazmat = 35;
          if (this_.has_hazmat_case() == kHazmat) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                35, this_._internal_hazmat(), target);
          }

          // float weight = 36;
          if (this_.has_weight_case() == kWeight) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                36, this_._internal_weight(), target);
          }

          // float axle_load = 37;
          if (this_.has_axle_load_case() == kAxleLoad) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                37, this_._internal_axle_load(), target);
          }

          // float height = 38;
          if (this_.has_height_case() == kHeight) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                38, this_._internal_height(), target);
          }

          // float width = 39;
          if (this_.has_width_case() == kWidth) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                39, this_._internal_width(), target);
          }

          // float length = 40;
          if (this_.has_length_case() == kLength) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                40, this_._internal_length(), target);
          }

          // float cycling_speed = 41;
          if (this_.has_cycling_speed_case() == kCyclingSpeed) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                41, this_._internal_cycling_speed(), target);
          }

          // bool wheelchair = 42;
          if (this_.has_wheelchair_case() == kWheelchair) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                42, this_._internal_wheelchair(), target);
          }

          // bool bicycle = 43;
          if (this_.has_bicycle_case() == kBicycle) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                43, this_._internal_bicycle(), target);
          }

          // float use_bus = 44;
          if (this_.has_use_bus_case() == kUseBus) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                44, this_._internal_use_bus(), target);
          }

          // float use_rail = 45;
          if (this_.has_use_rail_case() == kUseRail) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                45, this_._internal_use_rail(), target);
          }

          // float use_transfers = 46;
          if (this_.has_use_transfers_case() == kUseTransfers) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                46, this_._internal_use_transfers(), target);
          }

          // float transfer_cost = 47;
          if (this_.has_transfer_cost_case() == kTransferCost) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                47, this_._internal_transfer_cost(), target);
          }

          // float transfer_penalty = 48;
          if (this_.has_transfer_penalty_case() == kTransferPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                48, this_._internal_transfer_penalty(), target);
          }

          // .valhalla.FilterAction filter_stop_action = 49;
          if (this_._internal_filter_stop_action() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                49, this_._internal_filter_stop_action(), target);
          }

          // repeated string filter_stop_ids = 50;
          for (int i = 0, n = this_._internal_filter_stop_ids_size(); i < n; ++i) {
            const auto& s = this_._internal_filter_stop_ids().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Costing.Options.filter_stop_ids");
            target = stream->WriteString(50, s, target);
          }

          // .valhalla.FilterAction filter_operator_action = 51;
          if (this_._internal_filter_operator_action() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                51, this_._internal_filter_operator_action(), target);
          }

          // repeated string filter_operator_ids = 52;
          for (int i = 0, n = this_._internal_filter_operator_ids_size(); i < n; ++i) {
            const auto& s = this_._internal_filter_operator_ids().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Costing.Options.filter_operator_ids");
            target = stream->WriteString(52, s, target);
          }

          // .valhalla.FilterAction filter_route_action = 53;
          if (this_._internal_filter_route_action() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                53, this_._internal_filter_route_action(), target);
          }

          // repeated string filter_route_ids = 54;
          for (int i = 0, n = this_._internal_filter_route_ids_size(); i < n; ++i) {
            const auto& s = this_._internal_filter_route_ids().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Costing.Options.filter_route_ids");
            target = stream->WriteString(54, s, target);
          }

          // uint32 flow_mask = 55;
          if (this_.has_flow_mask_case() == kFlowMask) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                55, this_._internal_flow_mask(), target);
          }

          // float bike_share_cost = 56;
          if (this_.has_bike_share_cost_case() == kBikeShareCost) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                56, this_._internal_bike_share_cost(), target);
          }

          // float bike_share_penalty = 57;
          if (this_.has_bike_share_penalty_case() == kBikeSharePenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                57, this_._internal_bike_share_penalty(), target);
          }

          // float rail_ferry_cost = 58;
          if (this_.has_rail_ferry_cost_case() == kRailFerryCost) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                58, this_._internal_rail_ferry_cost(), target);
          }

          // float use_rail_ferry = 59;
          if (this_.has_use_rail_ferry_case() == kUseRailFerry) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                59, this_._internal_use_rail_ferry(), target);
          }

          // bool ignore_restrictions = 60;
          if (this_.has_ignore_restrictions_case() == kIgnoreRestrictions) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                60, this_._internal_ignore_restrictions(), target);
          }

          // bool ignore_oneways = 61;
          if (this_.has_ignore_oneways_case() == kIgnoreOneways) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                61, this_._internal_ignore_oneways(), target);
          }

          // bool ignore_access = 62;
          if (this_.has_ignore_access_case() == kIgnoreAccess) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                62, this_._internal_ignore_access(), target);
          }

          // bool ignore_closures = 63;
          if (this_.has_ignore_closures_case() == kIgnoreClosures) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                63, this_._internal_ignore_closures(), target);
          }

          // bool shortest = 64;
          if (this_.has_shortest_case() == kShortest) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                64, this_._internal_shortest(), target);
          }

          // float service_penalty = 65;
          if (this_.has_service_penalty_case() == kServicePenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                65, this_._internal_service_penalty(), target);
          }

          // float use_tracks = 66;
          if (this_.has_use_tracks_case() == kUseTracks) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                66, this_._internal_use_tracks(), target);
          }

          // float use_distance = 67;
          if (this_.has_use_distance_case() == kUseDistance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                67, this_._internal_use_distance(), target);
          }

          // float use_living_streets = 68;
          if (this_.has_use_living_streets_case() == kUseLivingStreets) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                68, this_._internal_use_living_streets(), target);
          }

          // float service_factor = 69;
          if (this_.has_service_factor_case() == kServiceFactor) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                69, this_._internal_service_factor(), target);
          }

          // float closure_factor = 70;
          if (this_.has_closure_factor_case() == kClosureFactor) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                70, this_._internal_closure_factor(), target);
          }

          // float private_access_penalty = 71;
          if (this_.has_private_access_penalty_case() == kPrivateAccessPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                71, this_._internal_private_access_penalty(), target);
          }

          // bool exclude_unpaved = 72;
          if (this_.has_exclude_unpaved_case() == kExcludeUnpaved) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                72, this_._internal_exclude_unpaved(), target);
          }

          // bool include_hot = 73;
          if (this_.has_include_hot_case() == kIncludeHot) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                73, this_._internal_include_hot(), target);
          }

          // bool include_hov2 = 74;
          if (this_.has_include_hov2_case() == kIncludeHov2) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                74, this_._internal_include_hov2(), target);
          }

          // bool include_hov3 = 75;
          if (this_.has_include_hov3_case() == kIncludeHov3) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                75, this_._internal_include_hov3(), target);
          }

          // bool exclude_cash_only_tolls = 76;
          if (this_.has_exclude_cash_only_tolls_case() == kExcludeCashOnlyTolls) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                76, this_._internal_exclude_cash_only_tolls(), target);
          }

          // uint32 restriction_probability = 77;
          if (this_.has_restriction_probability_case() == kRestrictionProbability) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                77, this_._internal_restriction_probability(), target);
          }

          // repeated .valhalla.AvoidEdge exclude_edges = 78;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_exclude_edges_size());
               i < n; i++) {
            const auto& repfield = this_._internal_exclude_edges().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    78, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // float elevator_penalty = 79;
          if (this_.has_elevator_penalty_case() == kElevatorPenalty) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                79, this_._internal_elevator_penalty(), target);
          }

          // uint32 fixed_speed = 80;
          if (this_._internal_fixed_speed() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                80, this_._internal_fixed_speed(), target);
          }

          // uint32 axle_count = 81;
          if (this_._internal_axle_count() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                81, this_._internal_axle_count(), target);
          }

          // float use_lit = 82;
          if (::absl::bit_cast<::uint32_t>(this_._internal_use_lit()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                82, this_._internal_use_lit(), target);
          }

          // bool disable_hierarchy_pruning = 83;
          if (this_._internal_disable_hierarchy_pruning() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                83, this_._internal_disable_hierarchy_pruning(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Costing.Options)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Costing_Options::ByteSizeLong(const MessageLite& base) {
          const Costing_Options& this_ = static_cast<const Costing_Options&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Costing_Options::ByteSizeLong() const {
          const Costing_Options& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Costing.Options)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated string filter_stop_ids = 50;
            {
              total_size +=
                  2 * ::google::protobuf::internal::FromIntSize(this_._internal_filter_stop_ids().size());
              for (int i = 0, n = this_._internal_filter_stop_ids().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_filter_stop_ids().Get(i));
              }
            }
            // repeated string filter_operator_ids = 52;
            {
              total_size +=
                  2 * ::google::protobuf::internal::FromIntSize(this_._internal_filter_operator_ids().size());
              for (int i = 0, n = this_._internal_filter_operator_ids().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_filter_operator_ids().Get(i));
              }
            }
            // repeated string filter_route_ids = 54;
            {
              total_size +=
                  2 * ::google::protobuf::internal::FromIntSize(this_._internal_filter_route_ids().size());
              for (int i = 0, n = this_._internal_filter_route_ids().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_filter_route_ids().Get(i));
              }
            }
            // repeated .valhalla.AvoidEdge exclude_edges = 78;
            {
              total_size += 2UL * this_._internal_exclude_edges_size();
              for (const auto& msg : this_._internal_exclude_edges()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // .valhalla.FilterAction filter_stop_action = 49;
            if (this_._internal_filter_stop_action() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_filter_stop_action());
            }
            // .valhalla.FilterAction filter_operator_action = 51;
            if (this_._internal_filter_operator_action() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_filter_operator_action());
            }
            // .valhalla.FilterAction filter_route_action = 53;
            if (this_._internal_filter_route_action() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_filter_route_action());
            }
            // uint32 fixed_speed = 80;
            if (this_._internal_fixed_speed() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_fixed_speed());
            }
            // uint32 axle_count = 81;
            if (this_._internal_axle_count() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_axle_count());
            }
            // float use_lit = 82;
            if (::absl::bit_cast<::uint32_t>(this_._internal_use_lit()) != 0) {
              total_size += 6;
            }
            // bool disable_hierarchy_pruning = 83;
            if (this_._internal_disable_hierarchy_pruning() != 0) {
              total_size += 3;
            }
          }
          switch (this_.has_maneuver_penalty_case()) {
            // float maneuver_penalty = 1;
            case kManeuverPenalty: {
              total_size += 5;
              break;
            }
            case HAS_MANEUVER_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_destination_only_penalty_case()) {
            // float destination_only_penalty = 2;
            case kDestinationOnlyPenalty: {
              total_size += 5;
              break;
            }
            case HAS_DESTINATION_ONLY_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_gate_cost_case()) {
            // float gate_cost = 3;
            case kGateCost: {
              total_size += 5;
              break;
            }
            case HAS_GATE_COST_NOT_SET: {
              break;
            }
          }
          switch (this_.has_gate_penalty_case()) {
            // float gate_penalty = 4;
            case kGatePenalty: {
              total_size += 5;
              break;
            }
            case HAS_GATE_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_toll_booth_cost_case()) {
            // float toll_booth_cost = 5;
            case kTollBoothCost: {
              total_size += 5;
              break;
            }
            case HAS_TOLL_BOOTH_COST_NOT_SET: {
              break;
            }
          }
          switch (this_.has_toll_booth_penalty_case()) {
            // float toll_booth_penalty = 6;
            case kTollBoothPenalty: {
              total_size += 5;
              break;
            }
            case HAS_TOLL_BOOTH_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_alley_penalty_case()) {
            // float alley_penalty = 7;
            case kAlleyPenalty: {
              total_size += 5;
              break;
            }
            case HAS_ALLEY_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_country_crossing_cost_case()) {
            // float country_crossing_cost = 8;
            case kCountryCrossingCost: {
              total_size += 5;
              break;
            }
            case HAS_COUNTRY_CROSSING_COST_NOT_SET: {
              break;
            }
          }
          switch (this_.has_country_crossing_penalty_case()) {
            // float country_crossing_penalty = 9;
            case kCountryCrossingPenalty: {
              total_size += 5;
              break;
            }
            case HAS_COUNTRY_CROSSING_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_ferry_cost_case()) {
            // float ferry_cost = 10;
            case kFerryCost: {
              total_size += 5;
              break;
            }
            case HAS_FERRY_COST_NOT_SET: {
              break;
            }
          }
          switch (this_.has_avoid_bad_surfaces_case()) {
            // float avoid_bad_surfaces = 11;
            case kAvoidBadSurfaces: {
              total_size += 5;
              break;
            }
            case HAS_AVOID_BAD_SURFACES_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_ferry_case()) {
            // float use_ferry = 12;
            case kUseFerry: {
              total_size += 5;
              break;
            }
            case HAS_USE_FERRY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_highways_case()) {
            // float use_highways = 13;
            case kUseHighways: {
              total_size += 5;
              break;
            }
            case HAS_USE_HIGHWAYS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_tolls_case()) {
            // float use_tolls = 14;
            case kUseTolls: {
              total_size += 5;
              break;
            }
            case HAS_USE_TOLLS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_roads_case()) {
            // float use_roads = 15;
            case kUseRoads: {
              total_size += 5;
              break;
            }
            case HAS_USE_ROADS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_max_distance_case()) {
            // uint32 max_distance = 16;
            case kMaxDistance: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_max_distance());
              break;
            }
            case HAS_MAX_DISTANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_walking_speed_case()) {
            // float walking_speed = 17;
            case kWalkingSpeed: {
              total_size += 6;
              break;
            }
            case HAS_WALKING_SPEED_NOT_SET: {
              break;
            }
          }
          switch (this_.has_step_penalty_case()) {
            // float step_penalty = 18;
            case kStepPenalty: {
              total_size += 6;
              break;
            }
            case HAS_STEP_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_max_grade_case()) {
            // uint32 max_grade = 19;
            case kMaxGrade: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_max_grade());
              break;
            }
            case HAS_MAX_GRADE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_max_hiking_difficulty_case()) {
            // uint32 max_hiking_difficulty = 20;
            case kMaxHikingDifficulty: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_max_hiking_difficulty());
              break;
            }
            case HAS_MAX_HIKING_DIFFICULTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_mode_factor_case()) {
            // float mode_factor = 21;
            case kModeFactor: {
              total_size += 6;
              break;
            }
            case HAS_MODE_FACTOR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_walkway_factor_case()) {
            // float walkway_factor = 22;
            case kWalkwayFactor: {
              total_size += 6;
              break;
            }
            case HAS_WALKWAY_FACTOR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_sidewalk_factor_case()) {
            // float sidewalk_factor = 23;
            case kSidewalkFactor: {
              total_size += 6;
              break;
            }
            case HAS_SIDEWALK_FACTOR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_alley_factor_case()) {
            // float alley_factor = 24;
            case kAlleyFactor: {
              total_size += 6;
              break;
            }
            case HAS_ALLEY_FACTOR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_driveway_factor_case()) {
            // float driveway_factor = 25;
            case kDrivewayFactor: {
              total_size += 6;
              break;
            }
            case HAS_DRIVEWAY_FACTOR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_driveway_penalty_case()) {
            // float driveway_penalty = 26;
            case kDrivewayPenalty: {
              total_size += 6;
              break;
            }
            case HAS_DRIVEWAY_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_transit_start_end_max_distance_case()) {
            // uint32 transit_start_end_max_distance = 27;
            case kTransitStartEndMaxDistance: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_transit_start_end_max_distance());
              break;
            }
            case HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_transit_transfer_max_distance_case()) {
            // uint32 transit_transfer_max_distance = 28;
            case kTransitTransferMaxDistance: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_transit_transfer_max_distance());
              break;
            }
            case HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_transport_type_case()) {
            // string transport_type = 29;
            case kTransportType: {
              total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_transport_type());
              break;
            }
            case HAS_TRANSPORT_TYPE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_top_speed_case()) {
            // float top_speed = 30;
            case kTopSpeed: {
              total_size += 6;
              break;
            }
            case HAS_TOP_SPEED_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_hills_case()) {
            // float use_hills = 31;
            case kUseHills: {
              total_size += 6;
              break;
            }
            case HAS_USE_HILLS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_primary_case()) {
            // float use_primary = 32;
            case kUsePrimary: {
              total_size += 6;
              break;
            }
            case HAS_USE_PRIMARY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_trails_case()) {
            // float use_trails = 33;
            case kUseTrails: {
              total_size += 6;
              break;
            }
            case HAS_USE_TRAILS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_low_class_penalty_case()) {
            // float low_class_penalty = 34;
            case kLowClassPenalty: {
              total_size += 6;
              break;
            }
            case HAS_LOW_CLASS_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_hazmat_case()) {
            // bool hazmat = 35;
            case kHazmat: {
              total_size += 3;
              break;
            }
            case HAS_HAZMAT_NOT_SET: {
              break;
            }
          }
          switch (this_.has_weight_case()) {
            // float weight = 36;
            case kWeight: {
              total_size += 6;
              break;
            }
            case HAS_WEIGHT_NOT_SET: {
              break;
            }
          }
          switch (this_.has_axle_load_case()) {
            // float axle_load = 37;
            case kAxleLoad: {
              total_size += 6;
              break;
            }
            case HAS_AXLE_LOAD_NOT_SET: {
              break;
            }
          }
          switch (this_.has_height_case()) {
            // float height = 38;
            case kHeight: {
              total_size += 6;
              break;
            }
            case HAS_HEIGHT_NOT_SET: {
              break;
            }
          }
          switch (this_.has_width_case()) {
            // float width = 39;
            case kWidth: {
              total_size += 6;
              break;
            }
            case HAS_WIDTH_NOT_SET: {
              break;
            }
          }
          switch (this_.has_length_case()) {
            // float length = 40;
            case kLength: {
              total_size += 6;
              break;
            }
            case HAS_LENGTH_NOT_SET: {
              break;
            }
          }
          switch (this_.has_cycling_speed_case()) {
            // float cycling_speed = 41;
            case kCyclingSpeed: {
              total_size += 6;
              break;
            }
            case HAS_CYCLING_SPEED_NOT_SET: {
              break;
            }
          }
          switch (this_.has_wheelchair_case()) {
            // bool wheelchair = 42;
            case kWheelchair: {
              total_size += 3;
              break;
            }
            case HAS_WHEELCHAIR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_bicycle_case()) {
            // bool bicycle = 43;
            case kBicycle: {
              total_size += 3;
              break;
            }
            case HAS_BICYCLE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_bus_case()) {
            // float use_bus = 44;
            case kUseBus: {
              total_size += 6;
              break;
            }
            case HAS_USE_BUS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_rail_case()) {
            // float use_rail = 45;
            case kUseRail: {
              total_size += 6;
              break;
            }
            case HAS_USE_RAIL_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_transfers_case()) {
            // float use_transfers = 46;
            case kUseTransfers: {
              total_size += 6;
              break;
            }
            case HAS_USE_TRANSFERS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_transfer_cost_case()) {
            // float transfer_cost = 47;
            case kTransferCost: {
              total_size += 6;
              break;
            }
            case HAS_TRANSFER_COST_NOT_SET: {
              break;
            }
          }
          switch (this_.has_transfer_penalty_case()) {
            // float transfer_penalty = 48;
            case kTransferPenalty: {
              total_size += 6;
              break;
            }
            case HAS_TRANSFER_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_flow_mask_case()) {
            // uint32 flow_mask = 55;
            case kFlowMask: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_flow_mask());
              break;
            }
            case HAS_FLOW_MASK_NOT_SET: {
              break;
            }
          }
          switch (this_.has_bike_share_cost_case()) {
            // float bike_share_cost = 56;
            case kBikeShareCost: {
              total_size += 6;
              break;
            }
            case HAS_BIKE_SHARE_COST_NOT_SET: {
              break;
            }
          }
          switch (this_.has_bike_share_penalty_case()) {
            // float bike_share_penalty = 57;
            case kBikeSharePenalty: {
              total_size += 6;
              break;
            }
            case HAS_BIKE_SHARE_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_rail_ferry_cost_case()) {
            // float rail_ferry_cost = 58;
            case kRailFerryCost: {
              total_size += 6;
              break;
            }
            case HAS_RAIL_FERRY_COST_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_rail_ferry_case()) {
            // float use_rail_ferry = 59;
            case kUseRailFerry: {
              total_size += 6;
              break;
            }
            case HAS_USE_RAIL_FERRY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_ignore_restrictions_case()) {
            // bool ignore_restrictions = 60;
            case kIgnoreRestrictions: {
              total_size += 3;
              break;
            }
            case HAS_IGNORE_RESTRICTIONS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_ignore_oneways_case()) {
            // bool ignore_oneways = 61;
            case kIgnoreOneways: {
              total_size += 3;
              break;
            }
            case HAS_IGNORE_ONEWAYS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_ignore_access_case()) {
            // bool ignore_access = 62;
            case kIgnoreAccess: {
              total_size += 3;
              break;
            }
            case HAS_IGNORE_ACCESS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_ignore_closures_case()) {
            // bool ignore_closures = 63;
            case kIgnoreClosures: {
              total_size += 3;
              break;
            }
            case HAS_IGNORE_CLOSURES_NOT_SET: {
              break;
            }
          }
          switch (this_.has_shortest_case()) {
            // bool shortest = 64;
            case kShortest: {
              total_size += 3;
              break;
            }
            case HAS_SHORTEST_NOT_SET: {
              break;
            }
          }
          switch (this_.has_service_penalty_case()) {
            // float service_penalty = 65;
            case kServicePenalty: {
              total_size += 6;
              break;
            }
            case HAS_SERVICE_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_tracks_case()) {
            // float use_tracks = 66;
            case kUseTracks: {
              total_size += 6;
              break;
            }
            case HAS_USE_TRACKS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_distance_case()) {
            // float use_distance = 67;
            case kUseDistance: {
              total_size += 6;
              break;
            }
            case HAS_USE_DISTANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_living_streets_case()) {
            // float use_living_streets = 68;
            case kUseLivingStreets: {
              total_size += 6;
              break;
            }
            case HAS_USE_LIVING_STREETS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_service_factor_case()) {
            // float service_factor = 69;
            case kServiceFactor: {
              total_size += 6;
              break;
            }
            case HAS_SERVICE_FACTOR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_closure_factor_case()) {
            // float closure_factor = 70;
            case kClosureFactor: {
              total_size += 6;
              break;
            }
            case HAS_CLOSURE_FACTOR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_private_access_penalty_case()) {
            // float private_access_penalty = 71;
            case kPrivateAccessPenalty: {
              total_size += 6;
              break;
            }
            case HAS_PRIVATE_ACCESS_PENALTY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_exclude_unpaved_case()) {
            // bool exclude_unpaved = 72;
            case kExcludeUnpaved: {
              total_size += 3;
              break;
            }
            case HAS_EXCLUDE_UNPAVED_NOT_SET: {
              break;
            }
          }
          switch (this_.has_include_hot_case()) {
            // bool include_hot = 73;
            case kIncludeHot: {
              total_size += 3;
              break;
            }
            case HAS_INCLUDE_HOT_NOT_SET: {
              break;
            }
          }
          switch (this_.has_include_hov2_case()) {
            // bool include_hov2 = 74;
            case kIncludeHov2: {
              total_size += 3;
              break;
            }
            case HAS_INCLUDE_HOV2_NOT_SET: {
              break;
            }
          }
          switch (this_.has_include_hov3_case()) {
            // bool include_hov3 = 75;
            case kIncludeHov3: {
              total_size += 3;
              break;
            }
            case HAS_INCLUDE_HOV3_NOT_SET: {
              break;
            }
          }
          switch (this_.has_exclude_cash_only_tolls_case()) {
            // bool exclude_cash_only_tolls = 76;
            case kExcludeCashOnlyTolls: {
              total_size += 3;
              break;
            }
            case HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_restriction_probability_case()) {
            // uint32 restriction_probability = 77;
            case kRestrictionProbability: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_restriction_probability());
              break;
            }
            case HAS_RESTRICTION_PROBABILITY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_elevator_penalty_case()) {
            // float elevator_penalty = 79;
            case kElevatorPenalty: {
              total_size += 6;
              break;
            }
            case HAS_ELEVATOR_PENALTY_NOT_SET: {
              break;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Costing_Options::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Costing_Options*>(&to_msg);
  auto& from = static_cast<const Costing_Options&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Costing.Options)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_filter_stop_ids()->MergeFrom(from._internal_filter_stop_ids());
  _this->_internal_mutable_filter_operator_ids()->MergeFrom(from._internal_filter_operator_ids());
  _this->_internal_mutable_filter_route_ids()->MergeFrom(from._internal_filter_route_ids());
  _this->_internal_mutable_exclude_edges()->MergeFrom(
      from._internal_exclude_edges());
  if (from._internal_filter_stop_action() != 0) {
    _this->_impl_.filter_stop_action_ = from._impl_.filter_stop_action_;
  }
  if (from._internal_filter_operator_action() != 0) {
    _this->_impl_.filter_operator_action_ = from._impl_.filter_operator_action_;
  }
  if (from._internal_filter_route_action() != 0) {
    _this->_impl_.filter_route_action_ = from._impl_.filter_route_action_;
  }
  if (from._internal_fixed_speed() != 0) {
    _this->_impl_.fixed_speed_ = from._impl_.fixed_speed_;
  }
  if (from._internal_axle_count() != 0) {
    _this->_impl_.axle_count_ = from._impl_.axle_count_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_use_lit()) != 0) {
    _this->_impl_.use_lit_ = from._impl_.use_lit_;
  }
  if (from._internal_disable_hierarchy_pruning() != 0) {
    _this->_impl_.disable_hierarchy_pruning_ = from._impl_.disable_hierarchy_pruning_;
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_maneuver_penalty();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kManeuverPenalty: {
        _this->_impl_.has_maneuver_penalty_.maneuver_penalty_ = from._impl_.has_maneuver_penalty_.maneuver_penalty_;
        break;
      }
      case HAS_MANEUVER_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_destination_only_penalty();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kDestinationOnlyPenalty: {
        _this->_impl_.has_destination_only_penalty_.destination_only_penalty_ = from._impl_.has_destination_only_penalty_.destination_only_penalty_;
        break;
      }
      case HAS_DESTINATION_ONLY_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[2]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[2];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_gate_cost();
      }
      _this->_impl_._oneof_case_[2] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGateCost: {
        _this->_impl_.has_gate_cost_.gate_cost_ = from._impl_.has_gate_cost_.gate_cost_;
        break;
      }
      case HAS_GATE_COST_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[3]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[3];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_gate_penalty();
      }
      _this->_impl_._oneof_case_[3] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGatePenalty: {
        _this->_impl_.has_gate_penalty_.gate_penalty_ = from._impl_.has_gate_penalty_.gate_penalty_;
        break;
      }
      case HAS_GATE_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[4]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[4];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_toll_booth_cost();
      }
      _this->_impl_._oneof_case_[4] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTollBoothCost: {
        _this->_impl_.has_toll_booth_cost_.toll_booth_cost_ = from._impl_.has_toll_booth_cost_.toll_booth_cost_;
        break;
      }
      case HAS_TOLL_BOOTH_COST_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[5]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[5];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_toll_booth_penalty();
      }
      _this->_impl_._oneof_case_[5] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTollBoothPenalty: {
        _this->_impl_.has_toll_booth_penalty_.toll_booth_penalty_ = from._impl_.has_toll_booth_penalty_.toll_booth_penalty_;
        break;
      }
      case HAS_TOLL_BOOTH_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[6]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[6];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_alley_penalty();
      }
      _this->_impl_._oneof_case_[6] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kAlleyPenalty: {
        _this->_impl_.has_alley_penalty_.alley_penalty_ = from._impl_.has_alley_penalty_.alley_penalty_;
        break;
      }
      case HAS_ALLEY_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[7]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[7];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_country_crossing_cost();
      }
      _this->_impl_._oneof_case_[7] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kCountryCrossingCost: {
        _this->_impl_.has_country_crossing_cost_.country_crossing_cost_ = from._impl_.has_country_crossing_cost_.country_crossing_cost_;
        break;
      }
      case HAS_COUNTRY_CROSSING_COST_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[8]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[8];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_country_crossing_penalty();
      }
      _this->_impl_._oneof_case_[8] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kCountryCrossingPenalty: {
        _this->_impl_.has_country_crossing_penalty_.country_crossing_penalty_ = from._impl_.has_country_crossing_penalty_.country_crossing_penalty_;
        break;
      }
      case HAS_COUNTRY_CROSSING_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[9]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[9];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_ferry_cost();
      }
      _this->_impl_._oneof_case_[9] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kFerryCost: {
        _this->_impl_.has_ferry_cost_.ferry_cost_ = from._impl_.has_ferry_cost_.ferry_cost_;
        break;
      }
      case HAS_FERRY_COST_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[10]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[10];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_avoid_bad_surfaces();
      }
      _this->_impl_._oneof_case_[10] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kAvoidBadSurfaces: {
        _this->_impl_.has_avoid_bad_surfaces_.avoid_bad_surfaces_ = from._impl_.has_avoid_bad_surfaces_.avoid_bad_surfaces_;
        break;
      }
      case HAS_AVOID_BAD_SURFACES_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[11]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[11];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_ferry();
      }
      _this->_impl_._oneof_case_[11] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseFerry: {
        _this->_impl_.has_use_ferry_.use_ferry_ = from._impl_.has_use_ferry_.use_ferry_;
        break;
      }
      case HAS_USE_FERRY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[12]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[12];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_highways();
      }
      _this->_impl_._oneof_case_[12] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseHighways: {
        _this->_impl_.has_use_highways_.use_highways_ = from._impl_.has_use_highways_.use_highways_;
        break;
      }
      case HAS_USE_HIGHWAYS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[13]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[13];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_tolls();
      }
      _this->_impl_._oneof_case_[13] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseTolls: {
        _this->_impl_.has_use_tolls_.use_tolls_ = from._impl_.has_use_tolls_.use_tolls_;
        break;
      }
      case HAS_USE_TOLLS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[14]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[14];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_roads();
      }
      _this->_impl_._oneof_case_[14] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseRoads: {
        _this->_impl_.has_use_roads_.use_roads_ = from._impl_.has_use_roads_.use_roads_;
        break;
      }
      case HAS_USE_ROADS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[15]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[15];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_max_distance();
      }
      _this->_impl_._oneof_case_[15] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kMaxDistance: {
        _this->_impl_.has_max_distance_.max_distance_ = from._impl_.has_max_distance_.max_distance_;
        break;
      }
      case HAS_MAX_DISTANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[16]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[16];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_walking_speed();
      }
      _this->_impl_._oneof_case_[16] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kWalkingSpeed: {
        _this->_impl_.has_walking_speed_.walking_speed_ = from._impl_.has_walking_speed_.walking_speed_;
        break;
      }
      case HAS_WALKING_SPEED_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[17]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[17];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_step_penalty();
      }
      _this->_impl_._oneof_case_[17] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kStepPenalty: {
        _this->_impl_.has_step_penalty_.step_penalty_ = from._impl_.has_step_penalty_.step_penalty_;
        break;
      }
      case HAS_STEP_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[18]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[18];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_max_grade();
      }
      _this->_impl_._oneof_case_[18] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kMaxGrade: {
        _this->_impl_.has_max_grade_.max_grade_ = from._impl_.has_max_grade_.max_grade_;
        break;
      }
      case HAS_MAX_GRADE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[19]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[19];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_max_hiking_difficulty();
      }
      _this->_impl_._oneof_case_[19] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kMaxHikingDifficulty: {
        _this->_impl_.has_max_hiking_difficulty_.max_hiking_difficulty_ = from._impl_.has_max_hiking_difficulty_.max_hiking_difficulty_;
        break;
      }
      case HAS_MAX_HIKING_DIFFICULTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[20]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[20];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_mode_factor();
      }
      _this->_impl_._oneof_case_[20] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kModeFactor: {
        _this->_impl_.has_mode_factor_.mode_factor_ = from._impl_.has_mode_factor_.mode_factor_;
        break;
      }
      case HAS_MODE_FACTOR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[21]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[21];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_walkway_factor();
      }
      _this->_impl_._oneof_case_[21] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kWalkwayFactor: {
        _this->_impl_.has_walkway_factor_.walkway_factor_ = from._impl_.has_walkway_factor_.walkway_factor_;
        break;
      }
      case HAS_WALKWAY_FACTOR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[22]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[22];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_sidewalk_factor();
      }
      _this->_impl_._oneof_case_[22] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kSidewalkFactor: {
        _this->_impl_.has_sidewalk_factor_.sidewalk_factor_ = from._impl_.has_sidewalk_factor_.sidewalk_factor_;
        break;
      }
      case HAS_SIDEWALK_FACTOR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[23]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[23];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_alley_factor();
      }
      _this->_impl_._oneof_case_[23] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kAlleyFactor: {
        _this->_impl_.has_alley_factor_.alley_factor_ = from._impl_.has_alley_factor_.alley_factor_;
        break;
      }
      case HAS_ALLEY_FACTOR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[24]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[24];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_driveway_factor();
      }
      _this->_impl_._oneof_case_[24] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kDrivewayFactor: {
        _this->_impl_.has_driveway_factor_.driveway_factor_ = from._impl_.has_driveway_factor_.driveway_factor_;
        break;
      }
      case HAS_DRIVEWAY_FACTOR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[25]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[25];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_driveway_penalty();
      }
      _this->_impl_._oneof_case_[25] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kDrivewayPenalty: {
        _this->_impl_.has_driveway_penalty_.driveway_penalty_ = from._impl_.has_driveway_penalty_.driveway_penalty_;
        break;
      }
      case HAS_DRIVEWAY_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[26]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[26];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_transit_start_end_max_distance();
      }
      _this->_impl_._oneof_case_[26] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTransitStartEndMaxDistance: {
        _this->_impl_.has_transit_start_end_max_distance_.transit_start_end_max_distance_ = from._impl_.has_transit_start_end_max_distance_.transit_start_end_max_distance_;
        break;
      }
      case HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[27]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[27];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_transit_transfer_max_distance();
      }
      _this->_impl_._oneof_case_[27] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTransitTransferMaxDistance: {
        _this->_impl_.has_transit_transfer_max_distance_.transit_transfer_max_distance_ = from._impl_.has_transit_transfer_max_distance_.transit_transfer_max_distance_;
        break;
      }
      case HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[28]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[28];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_transport_type();
      }
      _this->_impl_._oneof_case_[28] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTransportType: {
        if (oneof_needs_init) {
          _this->_impl_.has_transport_type_.transport_type_.InitDefault();
        }
        _this->_impl_.has_transport_type_.transport_type_.Set(from._internal_transport_type(), arena);
        break;
      }
      case HAS_TRANSPORT_TYPE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[29]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[29];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_top_speed();
      }
      _this->_impl_._oneof_case_[29] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTopSpeed: {
        _this->_impl_.has_top_speed_.top_speed_ = from._impl_.has_top_speed_.top_speed_;
        break;
      }
      case HAS_TOP_SPEED_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[30]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[30];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_hills();
      }
      _this->_impl_._oneof_case_[30] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseHills: {
        _this->_impl_.has_use_hills_.use_hills_ = from._impl_.has_use_hills_.use_hills_;
        break;
      }
      case HAS_USE_HILLS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[31]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[31];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_primary();
      }
      _this->_impl_._oneof_case_[31] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUsePrimary: {
        _this->_impl_.has_use_primary_.use_primary_ = from._impl_.has_use_primary_.use_primary_;
        break;
      }
      case HAS_USE_PRIMARY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[32]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[32];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_trails();
      }
      _this->_impl_._oneof_case_[32] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseTrails: {
        _this->_impl_.has_use_trails_.use_trails_ = from._impl_.has_use_trails_.use_trails_;
        break;
      }
      case HAS_USE_TRAILS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[33]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[33];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_low_class_penalty();
      }
      _this->_impl_._oneof_case_[33] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLowClassPenalty: {
        _this->_impl_.has_low_class_penalty_.low_class_penalty_ = from._impl_.has_low_class_penalty_.low_class_penalty_;
        break;
      }
      case HAS_LOW_CLASS_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[34]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[34];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_hazmat();
      }
      _this->_impl_._oneof_case_[34] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kHazmat: {
        _this->_impl_.has_hazmat_.hazmat_ = from._impl_.has_hazmat_.hazmat_;
        break;
      }
      case HAS_HAZMAT_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[35]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[35];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_weight();
      }
      _this->_impl_._oneof_case_[35] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kWeight: {
        _this->_impl_.has_weight_.weight_ = from._impl_.has_weight_.weight_;
        break;
      }
      case HAS_WEIGHT_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[36]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[36];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_axle_load();
      }
      _this->_impl_._oneof_case_[36] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kAxleLoad: {
        _this->_impl_.has_axle_load_.axle_load_ = from._impl_.has_axle_load_.axle_load_;
        break;
      }
      case HAS_AXLE_LOAD_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[37]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[37];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_height();
      }
      _this->_impl_._oneof_case_[37] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kHeight: {
        _this->_impl_.has_height_.height_ = from._impl_.has_height_.height_;
        break;
      }
      case HAS_HEIGHT_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[38]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[38];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_width();
      }
      _this->_impl_._oneof_case_[38] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kWidth: {
        _this->_impl_.has_width_.width_ = from._impl_.has_width_.width_;
        break;
      }
      case HAS_WIDTH_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[39]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[39];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_length();
      }
      _this->_impl_._oneof_case_[39] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLength: {
        _this->_impl_.has_length_.length_ = from._impl_.has_length_.length_;
        break;
      }
      case HAS_LENGTH_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[40]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[40];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_cycling_speed();
      }
      _this->_impl_._oneof_case_[40] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kCyclingSpeed: {
        _this->_impl_.has_cycling_speed_.cycling_speed_ = from._impl_.has_cycling_speed_.cycling_speed_;
        break;
      }
      case HAS_CYCLING_SPEED_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[41]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[41];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_wheelchair();
      }
      _this->_impl_._oneof_case_[41] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kWheelchair: {
        _this->_impl_.has_wheelchair_.wheelchair_ = from._impl_.has_wheelchair_.wheelchair_;
        break;
      }
      case HAS_WHEELCHAIR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[42]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[42];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_bicycle();
      }
      _this->_impl_._oneof_case_[42] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kBicycle: {
        _this->_impl_.has_bicycle_.bicycle_ = from._impl_.has_bicycle_.bicycle_;
        break;
      }
      case HAS_BICYCLE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[43]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[43];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_bus();
      }
      _this->_impl_._oneof_case_[43] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseBus: {
        _this->_impl_.has_use_bus_.use_bus_ = from._impl_.has_use_bus_.use_bus_;
        break;
      }
      case HAS_USE_BUS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[44]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[44];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_rail();
      }
      _this->_impl_._oneof_case_[44] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseRail: {
        _this->_impl_.has_use_rail_.use_rail_ = from._impl_.has_use_rail_.use_rail_;
        break;
      }
      case HAS_USE_RAIL_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[45]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[45];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_transfers();
      }
      _this->_impl_._oneof_case_[45] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseTransfers: {
        _this->_impl_.has_use_transfers_.use_transfers_ = from._impl_.has_use_transfers_.use_transfers_;
        break;
      }
      case HAS_USE_TRANSFERS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[46]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[46];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_transfer_cost();
      }
      _this->_impl_._oneof_case_[46] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTransferCost: {
        _this->_impl_.has_transfer_cost_.transfer_cost_ = from._impl_.has_transfer_cost_.transfer_cost_;
        break;
      }
      case HAS_TRANSFER_COST_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[47]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[47];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_transfer_penalty();
      }
      _this->_impl_._oneof_case_[47] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTransferPenalty: {
        _this->_impl_.has_transfer_penalty_.transfer_penalty_ = from._impl_.has_transfer_penalty_.transfer_penalty_;
        break;
      }
      case HAS_TRANSFER_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[48]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[48];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_flow_mask();
      }
      _this->_impl_._oneof_case_[48] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kFlowMask: {
        _this->_impl_.has_flow_mask_.flow_mask_ = from._impl_.has_flow_mask_.flow_mask_;
        break;
      }
      case HAS_FLOW_MASK_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[49]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[49];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_bike_share_cost();
      }
      _this->_impl_._oneof_case_[49] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kBikeShareCost: {
        _this->_impl_.has_bike_share_cost_.bike_share_cost_ = from._impl_.has_bike_share_cost_.bike_share_cost_;
        break;
      }
      case HAS_BIKE_SHARE_COST_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[50]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[50];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_bike_share_penalty();
      }
      _this->_impl_._oneof_case_[50] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kBikeSharePenalty: {
        _this->_impl_.has_bike_share_penalty_.bike_share_penalty_ = from._impl_.has_bike_share_penalty_.bike_share_penalty_;
        break;
      }
      case HAS_BIKE_SHARE_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[51]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[51];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_rail_ferry_cost();
      }
      _this->_impl_._oneof_case_[51] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kRailFerryCost: {
        _this->_impl_.has_rail_ferry_cost_.rail_ferry_cost_ = from._impl_.has_rail_ferry_cost_.rail_ferry_cost_;
        break;
      }
      case HAS_RAIL_FERRY_COST_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[52]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[52];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_rail_ferry();
      }
      _this->_impl_._oneof_case_[52] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseRailFerry: {
        _this->_impl_.has_use_rail_ferry_.use_rail_ferry_ = from._impl_.has_use_rail_ferry_.use_rail_ferry_;
        break;
      }
      case HAS_USE_RAIL_FERRY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[53]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[53];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_ignore_restrictions();
      }
      _this->_impl_._oneof_case_[53] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kIgnoreRestrictions: {
        _this->_impl_.has_ignore_restrictions_.ignore_restrictions_ = from._impl_.has_ignore_restrictions_.ignore_restrictions_;
        break;
      }
      case HAS_IGNORE_RESTRICTIONS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[54]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[54];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_ignore_oneways();
      }
      _this->_impl_._oneof_case_[54] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kIgnoreOneways: {
        _this->_impl_.has_ignore_oneways_.ignore_oneways_ = from._impl_.has_ignore_oneways_.ignore_oneways_;
        break;
      }
      case HAS_IGNORE_ONEWAYS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[55]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[55];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_ignore_access();
      }
      _this->_impl_._oneof_case_[55] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kIgnoreAccess: {
        _this->_impl_.has_ignore_access_.ignore_access_ = from._impl_.has_ignore_access_.ignore_access_;
        break;
      }
      case HAS_IGNORE_ACCESS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[56]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[56];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_ignore_closures();
      }
      _this->_impl_._oneof_case_[56] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kIgnoreClosures: {
        _this->_impl_.has_ignore_closures_.ignore_closures_ = from._impl_.has_ignore_closures_.ignore_closures_;
        break;
      }
      case HAS_IGNORE_CLOSURES_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[57]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[57];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_shortest();
      }
      _this->_impl_._oneof_case_[57] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kShortest: {
        _this->_impl_.has_shortest_.shortest_ = from._impl_.has_shortest_.shortest_;
        break;
      }
      case HAS_SHORTEST_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[58]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[58];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_service_penalty();
      }
      _this->_impl_._oneof_case_[58] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kServicePenalty: {
        _this->_impl_.has_service_penalty_.service_penalty_ = from._impl_.has_service_penalty_.service_penalty_;
        break;
      }
      case HAS_SERVICE_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[59]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[59];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_tracks();
      }
      _this->_impl_._oneof_case_[59] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseTracks: {
        _this->_impl_.has_use_tracks_.use_tracks_ = from._impl_.has_use_tracks_.use_tracks_;
        break;
      }
      case HAS_USE_TRACKS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[60]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[60];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_distance();
      }
      _this->_impl_._oneof_case_[60] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseDistance: {
        _this->_impl_.has_use_distance_.use_distance_ = from._impl_.has_use_distance_.use_distance_;
        break;
      }
      case HAS_USE_DISTANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[61]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[61];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_living_streets();
      }
      _this->_impl_._oneof_case_[61] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseLivingStreets: {
        _this->_impl_.has_use_living_streets_.use_living_streets_ = from._impl_.has_use_living_streets_.use_living_streets_;
        break;
      }
      case HAS_USE_LIVING_STREETS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[62]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[62];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_service_factor();
      }
      _this->_impl_._oneof_case_[62] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kServiceFactor: {
        _this->_impl_.has_service_factor_.service_factor_ = from._impl_.has_service_factor_.service_factor_;
        break;
      }
      case HAS_SERVICE_FACTOR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[63]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[63];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_closure_factor();
      }
      _this->_impl_._oneof_case_[63] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kClosureFactor: {
        _this->_impl_.has_closure_factor_.closure_factor_ = from._impl_.has_closure_factor_.closure_factor_;
        break;
      }
      case HAS_CLOSURE_FACTOR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[64]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[64];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_private_access_penalty();
      }
      _this->_impl_._oneof_case_[64] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kPrivateAccessPenalty: {
        _this->_impl_.has_private_access_penalty_.private_access_penalty_ = from._impl_.has_private_access_penalty_.private_access_penalty_;
        break;
      }
      case HAS_PRIVATE_ACCESS_PENALTY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[65]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[65];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_exclude_unpaved();
      }
      _this->_impl_._oneof_case_[65] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kExcludeUnpaved: {
        _this->_impl_.has_exclude_unpaved_.exclude_unpaved_ = from._impl_.has_exclude_unpaved_.exclude_unpaved_;
        break;
      }
      case HAS_EXCLUDE_UNPAVED_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[66]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[66];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_include_hot();
      }
      _this->_impl_._oneof_case_[66] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kIncludeHot: {
        _this->_impl_.has_include_hot_.include_hot_ = from._impl_.has_include_hot_.include_hot_;
        break;
      }
      case HAS_INCLUDE_HOT_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[67]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[67];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_include_hov2();
      }
      _this->_impl_._oneof_case_[67] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kIncludeHov2: {
        _this->_impl_.has_include_hov2_.include_hov2_ = from._impl_.has_include_hov2_.include_hov2_;
        break;
      }
      case HAS_INCLUDE_HOV2_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[68]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[68];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_include_hov3();
      }
      _this->_impl_._oneof_case_[68] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kIncludeHov3: {
        _this->_impl_.has_include_hov3_.include_hov3_ = from._impl_.has_include_hov3_.include_hov3_;
        break;
      }
      case HAS_INCLUDE_HOV3_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[69]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[69];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_exclude_cash_only_tolls();
      }
      _this->_impl_._oneof_case_[69] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kExcludeCashOnlyTolls: {
        _this->_impl_.has_exclude_cash_only_tolls_.exclude_cash_only_tolls_ = from._impl_.has_exclude_cash_only_tolls_.exclude_cash_only_tolls_;
        break;
      }
      case HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[70]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[70];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_restriction_probability();
      }
      _this->_impl_._oneof_case_[70] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kRestrictionProbability: {
        _this->_impl_.has_restriction_probability_.restriction_probability_ = from._impl_.has_restriction_probability_.restriction_probability_;
        break;
      }
      case HAS_RESTRICTION_PROBABILITY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[71]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[71];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_elevator_penalty();
      }
      _this->_impl_._oneof_case_[71] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kElevatorPenalty: {
        _this->_impl_.has_elevator_penalty_.elevator_penalty_ = from._impl_.has_elevator_penalty_.elevator_penalty_;
        break;
      }
      case HAS_ELEVATOR_PENALTY_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Costing_Options::CopyFrom(const Costing_Options& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Costing.Options)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Costing_Options::InternalSwap(Costing_Options* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.filter_stop_ids_.InternalSwap(&other->_impl_.filter_stop_ids_);
  _impl_.filter_operator_ids_.InternalSwap(&other->_impl_.filter_operator_ids_);
  _impl_.filter_route_ids_.InternalSwap(&other->_impl_.filter_route_ids_);
  _impl_.exclude_edges_.InternalSwap(&other->_impl_.exclude_edges_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.disable_hierarchy_pruning_)
      + sizeof(Costing_Options::_impl_.disable_hierarchy_pruning_)
      - PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_stop_action_)>(
          reinterpret_cast<char*>(&_impl_.filter_stop_action_),
          reinterpret_cast<char*>(&other->_impl_.filter_stop_action_));
  swap(_impl_.has_maneuver_penalty_, other->_impl_.has_maneuver_penalty_);
  swap(_impl_.has_destination_only_penalty_, other->_impl_.has_destination_only_penalty_);
  swap(_impl_.has_gate_cost_, other->_impl_.has_gate_cost_);
  swap(_impl_.has_gate_penalty_, other->_impl_.has_gate_penalty_);
  swap(_impl_.has_toll_booth_cost_, other->_impl_.has_toll_booth_cost_);
  swap(_impl_.has_toll_booth_penalty_, other->_impl_.has_toll_booth_penalty_);
  swap(_impl_.has_alley_penalty_, other->_impl_.has_alley_penalty_);
  swap(_impl_.has_country_crossing_cost_, other->_impl_.has_country_crossing_cost_);
  swap(_impl_.has_country_crossing_penalty_, other->_impl_.has_country_crossing_penalty_);
  swap(_impl_.has_ferry_cost_, other->_impl_.has_ferry_cost_);
  swap(_impl_.has_avoid_bad_surfaces_, other->_impl_.has_avoid_bad_surfaces_);
  swap(_impl_.has_use_ferry_, other->_impl_.has_use_ferry_);
  swap(_impl_.has_use_highways_, other->_impl_.has_use_highways_);
  swap(_impl_.has_use_tolls_, other->_impl_.has_use_tolls_);
  swap(_impl_.has_use_roads_, other->_impl_.has_use_roads_);
  swap(_impl_.has_max_distance_, other->_impl_.has_max_distance_);
  swap(_impl_.has_walking_speed_, other->_impl_.has_walking_speed_);
  swap(_impl_.has_step_penalty_, other->_impl_.has_step_penalty_);
  swap(_impl_.has_max_grade_, other->_impl_.has_max_grade_);
  swap(_impl_.has_max_hiking_difficulty_, other->_impl_.has_max_hiking_difficulty_);
  swap(_impl_.has_mode_factor_, other->_impl_.has_mode_factor_);
  swap(_impl_.has_walkway_factor_, other->_impl_.has_walkway_factor_);
  swap(_impl_.has_sidewalk_factor_, other->_impl_.has_sidewalk_factor_);
  swap(_impl_.has_alley_factor_, other->_impl_.has_alley_factor_);
  swap(_impl_.has_driveway_factor_, other->_impl_.has_driveway_factor_);
  swap(_impl_.has_driveway_penalty_, other->_impl_.has_driveway_penalty_);
  swap(_impl_.has_transit_start_end_max_distance_, other->_impl_.has_transit_start_end_max_distance_);
  swap(_impl_.has_transit_transfer_max_distance_, other->_impl_.has_transit_transfer_max_distance_);
  swap(_impl_.has_transport_type_, other->_impl_.has_transport_type_);
  swap(_impl_.has_top_speed_, other->_impl_.has_top_speed_);
  swap(_impl_.has_use_hills_, other->_impl_.has_use_hills_);
  swap(_impl_.has_use_primary_, other->_impl_.has_use_primary_);
  swap(_impl_.has_use_trails_, other->_impl_.has_use_trails_);
  swap(_impl_.has_low_class_penalty_, other->_impl_.has_low_class_penalty_);
  swap(_impl_.has_hazmat_, other->_impl_.has_hazmat_);
  swap(_impl_.has_weight_, other->_impl_.has_weight_);
  swap(_impl_.has_axle_load_, other->_impl_.has_axle_load_);
  swap(_impl_.has_height_, other->_impl_.has_height_);
  swap(_impl_.has_width_, other->_impl_.has_width_);
  swap(_impl_.has_length_, other->_impl_.has_length_);
  swap(_impl_.has_cycling_speed_, other->_impl_.has_cycling_speed_);
  swap(_impl_.has_wheelchair_, other->_impl_.has_wheelchair_);
  swap(_impl_.has_bicycle_, other->_impl_.has_bicycle_);
  swap(_impl_.has_use_bus_, other->_impl_.has_use_bus_);
  swap(_impl_.has_use_rail_, other->_impl_.has_use_rail_);
  swap(_impl_.has_use_transfers_, other->_impl_.has_use_transfers_);
  swap(_impl_.has_transfer_cost_, other->_impl_.has_transfer_cost_);
  swap(_impl_.has_transfer_penalty_, other->_impl_.has_transfer_penalty_);
  swap(_impl_.has_flow_mask_, other->_impl_.has_flow_mask_);
  swap(_impl_.has_bike_share_cost_, other->_impl_.has_bike_share_cost_);
  swap(_impl_.has_bike_share_penalty_, other->_impl_.has_bike_share_penalty_);
  swap(_impl_.has_rail_ferry_cost_, other->_impl_.has_rail_ferry_cost_);
  swap(_impl_.has_use_rail_ferry_, other->_impl_.has_use_rail_ferry_);
  swap(_impl_.has_ignore_restrictions_, other->_impl_.has_ignore_restrictions_);
  swap(_impl_.has_ignore_oneways_, other->_impl_.has_ignore_oneways_);
  swap(_impl_.has_ignore_access_, other->_impl_.has_ignore_access_);
  swap(_impl_.has_ignore_closures_, other->_impl_.has_ignore_closures_);
  swap(_impl_.has_shortest_, other->_impl_.has_shortest_);
  swap(_impl_.has_service_penalty_, other->_impl_.has_service_penalty_);
  swap(_impl_.has_use_tracks_, other->_impl_.has_use_tracks_);
  swap(_impl_.has_use_distance_, other->_impl_.has_use_distance_);
  swap(_impl_.has_use_living_streets_, other->_impl_.has_use_living_streets_);
  swap(_impl_.has_service_factor_, other->_impl_.has_service_factor_);
  swap(_impl_.has_closure_factor_, other->_impl_.has_closure_factor_);
  swap(_impl_.has_private_access_penalty_, other->_impl_.has_private_access_penalty_);
  swap(_impl_.has_exclude_unpaved_, other->_impl_.has_exclude_unpaved_);
  swap(_impl_.has_include_hot_, other->_impl_.has_include_hot_);
  swap(_impl_.has_include_hov2_, other->_impl_.has_include_hov2_);
  swap(_impl_.has_include_hov3_, other->_impl_.has_include_hov3_);
  swap(_impl_.has_exclude_cash_only_tolls_, other->_impl_.has_exclude_cash_only_tolls_);
  swap(_impl_.has_restriction_probability_, other->_impl_.has_restriction_probability_);
  swap(_impl_.has_elevator_penalty_, other->_impl_.has_elevator_penalty_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
  swap(_impl_._oneof_case_[5], other->_impl_._oneof_case_[5]);
  swap(_impl_._oneof_case_[6], other->_impl_._oneof_case_[6]);
  swap(_impl_._oneof_case_[7], other->_impl_._oneof_case_[7]);
  swap(_impl_._oneof_case_[8], other->_impl_._oneof_case_[8]);
  swap(_impl_._oneof_case_[9], other->_impl_._oneof_case_[9]);
  swap(_impl_._oneof_case_[10], other->_impl_._oneof_case_[10]);
  swap(_impl_._oneof_case_[11], other->_impl_._oneof_case_[11]);
  swap(_impl_._oneof_case_[12], other->_impl_._oneof_case_[12]);
  swap(_impl_._oneof_case_[13], other->_impl_._oneof_case_[13]);
  swap(_impl_._oneof_case_[14], other->_impl_._oneof_case_[14]);
  swap(_impl_._oneof_case_[15], other->_impl_._oneof_case_[15]);
  swap(_impl_._oneof_case_[16], other->_impl_._oneof_case_[16]);
  swap(_impl_._oneof_case_[17], other->_impl_._oneof_case_[17]);
  swap(_impl_._oneof_case_[18], other->_impl_._oneof_case_[18]);
  swap(_impl_._oneof_case_[19], other->_impl_._oneof_case_[19]);
  swap(_impl_._oneof_case_[20], other->_impl_._oneof_case_[20]);
  swap(_impl_._oneof_case_[21], other->_impl_._oneof_case_[21]);
  swap(_impl_._oneof_case_[22], other->_impl_._oneof_case_[22]);
  swap(_impl_._oneof_case_[23], other->_impl_._oneof_case_[23]);
  swap(_impl_._oneof_case_[24], other->_impl_._oneof_case_[24]);
  swap(_impl_._oneof_case_[25], other->_impl_._oneof_case_[25]);
  swap(_impl_._oneof_case_[26], other->_impl_._oneof_case_[26]);
  swap(_impl_._oneof_case_[27], other->_impl_._oneof_case_[27]);
  swap(_impl_._oneof_case_[28], other->_impl_._oneof_case_[28]);
  swap(_impl_._oneof_case_[29], other->_impl_._oneof_case_[29]);
  swap(_impl_._oneof_case_[30], other->_impl_._oneof_case_[30]);
  swap(_impl_._oneof_case_[31], other->_impl_._oneof_case_[31]);
  swap(_impl_._oneof_case_[32], other->_impl_._oneof_case_[32]);
  swap(_impl_._oneof_case_[33], other->_impl_._oneof_case_[33]);
  swap(_impl_._oneof_case_[34], other->_impl_._oneof_case_[34]);
  swap(_impl_._oneof_case_[35], other->_impl_._oneof_case_[35]);
  swap(_impl_._oneof_case_[36], other->_impl_._oneof_case_[36]);
  swap(_impl_._oneof_case_[37], other->_impl_._oneof_case_[37]);
  swap(_impl_._oneof_case_[38], other->_impl_._oneof_case_[38]);
  swap(_impl_._oneof_case_[39], other->_impl_._oneof_case_[39]);
  swap(_impl_._oneof_case_[40], other->_impl_._oneof_case_[40]);
  swap(_impl_._oneof_case_[41], other->_impl_._oneof_case_[41]);
  swap(_impl_._oneof_case_[42], other->_impl_._oneof_case_[42]);
  swap(_impl_._oneof_case_[43], other->_impl_._oneof_case_[43]);
  swap(_impl_._oneof_case_[44], other->_impl_._oneof_case_[44]);
  swap(_impl_._oneof_case_[45], other->_impl_._oneof_case_[45]);
  swap(_impl_._oneof_case_[46], other->_impl_._oneof_case_[46]);
  swap(_impl_._oneof_case_[47], other->_impl_._oneof_case_[47]);
  swap(_impl_._oneof_case_[48], other->_impl_._oneof_case_[48]);
  swap(_impl_._oneof_case_[49], other->_impl_._oneof_case_[49]);
  swap(_impl_._oneof_case_[50], other->_impl_._oneof_case_[50]);
  swap(_impl_._oneof_case_[51], other->_impl_._oneof_case_[51]);
  swap(_impl_._oneof_case_[52], other->_impl_._oneof_case_[52]);
  swap(_impl_._oneof_case_[53], other->_impl_._oneof_case_[53]);
  swap(_impl_._oneof_case_[54], other->_impl_._oneof_case_[54]);
  swap(_impl_._oneof_case_[55], other->_impl_._oneof_case_[55]);
  swap(_impl_._oneof_case_[56], other->_impl_._oneof_case_[56]);
  swap(_impl_._oneof_case_[57], other->_impl_._oneof_case_[57]);
  swap(_impl_._oneof_case_[58], other->_impl_._oneof_case_[58]);
  swap(_impl_._oneof_case_[59], other->_impl_._oneof_case_[59]);
  swap(_impl_._oneof_case_[60], other->_impl_._oneof_case_[60]);
  swap(_impl_._oneof_case_[61], other->_impl_._oneof_case_[61]);
  swap(_impl_._oneof_case_[62], other->_impl_._oneof_case_[62]);
  swap(_impl_._oneof_case_[63], other->_impl_._oneof_case_[63]);
  swap(_impl_._oneof_case_[64], other->_impl_._oneof_case_[64]);
  swap(_impl_._oneof_case_[65], other->_impl_._oneof_case_[65]);
  swap(_impl_._oneof_case_[66], other->_impl_._oneof_case_[66]);
  swap(_impl_._oneof_case_[67], other->_impl_._oneof_case_[67]);
  swap(_impl_._oneof_case_[68], other->_impl_._oneof_case_[68]);
  swap(_impl_._oneof_case_[69], other->_impl_._oneof_case_[69]);
  swap(_impl_._oneof_case_[70], other->_impl_._oneof_case_[70]);
  swap(_impl_._oneof_case_[71], other->_impl_._oneof_case_[71]);
}

// ===================================================================

class Costing::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::valhalla::Costing, _impl_._oneof_case_);
};

void Costing::set_allocated_options(::valhalla::Costing_Options* options) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_has_options();
  if (options) {
    ::google::protobuf::Arena* submessage_arena = options->GetArena();
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(message_arena, options, submessage_arena);
    }
    set_has_options();
    _impl_.has_options_.options_ = options;
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Costing.options)
}
Costing::Costing(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Costing)
}
inline PROTOBUF_NDEBUG_INLINE Costing::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Costing& from_msg)
      : has_options_{},
        has_name_{},
        has_filter_closures_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1], from._oneof_case_[2]} {}

Costing::Costing(
    ::google::protobuf::Arena* arena,
    const Costing& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Costing* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.type_ = from._impl_.type_;
  switch (has_options_case()) {
    case HAS_OPTIONS_NOT_SET:
      break;
      case kOptions:
        _impl_.has_options_.options_ = ::google::protobuf::MessageLite::CopyConstruct<::valhalla::Costing_Options>(arena, *from._impl_.has_options_.options_);
        break;
  }
  switch (has_name_case()) {
    case HAS_NAME_NOT_SET:
      break;
      case kName:
        new (&_impl_.has_name_.name_) decltype(_impl_.has_name_.name_){arena, from._impl_.has_name_.name_};
        break;
  }
  switch (has_filter_closures_case()) {
    case HAS_FILTER_CLOSURES_NOT_SET:
      break;
      case kFilterClosures:
        _impl_.has_filter_closures_.filter_closures_ = from._impl_.has_filter_closures_.filter_closures_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.Costing)
}
inline PROTOBUF_NDEBUG_INLINE Costing::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : has_options_{},
        has_name_{},
        has_filter_closures_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void Costing::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.type_ = {};
}
Costing::~Costing() {
  // @@protoc_insertion_point(destructor:valhalla.Costing)
  SharedDtor(*this);
}
inline void Costing::SharedDtor(MessageLite& self) {
  Costing& this_ = static_cast<Costing&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_has_options()) {
    this_.clear_has_options();
  }
  if (this_.has_has_name()) {
    this_.clear_has_name();
  }
  if (this_.has_has_filter_closures()) {
    this_.clear_has_filter_closures();
  }
  this_._impl_.~Impl_();
}

void Costing::clear_has_options() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_options_case()) {
    case kOptions: {
      if (GetArena() == nullptr) {
        delete _impl_.has_options_.options_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        if (_impl_.has_options_.options_ != nullptr) {
          _impl_.has_options_.options_->Clear();
        }
      }
      break;
    }
    case HAS_OPTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_OPTIONS_NOT_SET;
}

void Costing::clear_has_name() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_name_case()) {
    case kName: {
      _impl_.has_name_.name_.Destroy();
      break;
    }
    case HAS_NAME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_NAME_NOT_SET;
}

void Costing::clear_has_filter_closures() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_filter_closures_case()) {
    case kFilterClosures: {
      // No need to clear
      break;
    }
    case HAS_FILTER_CLOSURES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_FILTER_CLOSURES_NOT_SET;
}


inline void* Costing::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Costing(arena);
}
constexpr auto Costing::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Costing),
                                            alignof(Costing));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<17> Costing::_class_data_ = {
    {
        &_Costing_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Costing::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Costing>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Costing::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Costing>(), &Costing::ByteSizeLong,
            &Costing::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Costing, _impl_._cached_size_),
        true,
    },
    "valhalla.Costing",
};
const ::google::protobuf::internal::ClassData* Costing::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 4, 1, 29, 2> Costing::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Costing>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .valhalla.Costing.Type type = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Costing, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.Costing.Options options = 1;
    {PROTOBUF_FIELD_OFFSET(Costing, _impl_.has_options_.options_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.Costing.Type type = 2;
    {PROTOBUF_FIELD_OFFSET(Costing, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string name = 3;
    {PROTOBUF_FIELD_OFFSET(Costing, _impl_.has_name_.name_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool filter_closures = 4;
    {PROTOBUF_FIELD_OFFSET(Costing, _impl_.has_filter_closures_.filter_closures_), _Internal::kOneofCaseOffset + 8, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::Costing_Options>()},
  }}, {{
    "\20\0\0\4\0\0\0\0"
    "valhalla.Costing"
    "name"
  }},
};

PROTOBUF_NOINLINE void Costing::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Costing)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  clear_has_options();
  clear_has_name();
  clear_has_filter_closures();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Costing::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Costing& this_ = static_cast<const Costing&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Costing::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Costing& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Costing)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // .valhalla.Costing.Options options = 1;
          if (this_.has_options_case() == kOptions) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.has_options_.options_, this_._impl_.has_options_.options_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.Costing.Type type = 2;
          if (this_._internal_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_type(), target);
          }

          // string name = 3;
          if (this_.has_name_case() == kName) {
            const std::string& _s = this_._internal_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Costing.name");
            target = stream->WriteStringMaybeAliased(3, _s, target);
          }

          // bool filter_closures = 4;
          if (this_.has_filter_closures_case() == kFilterClosures) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                4, this_._internal_filter_closures(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Costing)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Costing::ByteSizeLong(const MessageLite& base) {
          const Costing& this_ = static_cast<const Costing&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Costing::ByteSizeLong() const {
          const Costing& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Costing)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

           {
            // .valhalla.Costing.Type type = 2;
            if (this_._internal_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
          }
          switch (this_.has_options_case()) {
            // .valhalla.Costing.Options options = 1;
            case kOptions: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.has_options_.options_);
              break;
            }
            case HAS_OPTIONS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_name_case()) {
            // string name = 3;
            case kName: {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_name());
              break;
            }
            case HAS_NAME_NOT_SET: {
              break;
            }
          }
          switch (this_.has_filter_closures_case()) {
            // bool filter_closures = 4;
            case kFilterClosures: {
              total_size += 2;
              break;
            }
            case HAS_FILTER_CLOSURES_NOT_SET: {
              break;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Costing::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Costing*>(&to_msg);
  auto& from = static_cast<const Costing&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Costing)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_options();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kOptions: {
        if (oneof_needs_init) {
          _this->_impl_.has_options_.options_ =
              ::google::protobuf::MessageLite::CopyConstruct<::valhalla::Costing_Options>(arena, *from._impl_.has_options_.options_);
        } else {
          _this->_impl_.has_options_.options_->MergeFrom(from._internal_options());
        }
        break;
      }
      case HAS_OPTIONS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_name();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kName: {
        if (oneof_needs_init) {
          _this->_impl_.has_name_.name_.InitDefault();
        }
        _this->_impl_.has_name_.name_.Set(from._internal_name(), arena);
        break;
      }
      case HAS_NAME_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[2]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[2];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_filter_closures();
      }
      _this->_impl_._oneof_case_[2] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kFilterClosures: {
        _this->_impl_.has_filter_closures_.filter_closures_ = from._impl_.has_filter_closures_.filter_closures_;
        break;
      }
      case HAS_FILTER_CLOSURES_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Costing::CopyFrom(const Costing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Costing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Costing::InternalSwap(Costing* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_.has_options_, other->_impl_.has_options_);
  swap(_impl_.has_name_, other->_impl_.has_name_);
  swap(_impl_.has_filter_closures_, other->_impl_.has_filter_closures_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
}

// ===================================================================

// ===================================================================

class Options::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Options>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Options, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::valhalla::Options, _impl_._oneof_case_);
};

void Options::clear_locations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locations_.Clear();
}
void Options::clear_exclude_locations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exclude_locations_.Clear();
}
void Options::clear_sources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sources_.Clear();
}
void Options::clear_targets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targets_.Clear();
}
void Options::clear_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_.Clear();
}
void Options::clear_trace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_.Clear();
}
Options::Options(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Options)
}
inline PROTOBUF_NDEBUG_INLINE Options::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Options& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        costings_{visibility, arena, from.costings_},
        locations_{visibility, arena, from.locations_},
        exclude_locations_{visibility, arena, from.exclude_locations_},
        sources_{visibility, arena, from.sources_},
        targets_{visibility, arena, from.targets_},
        shape_{visibility, arena, from.shape_},
        contours_{visibility, arena, from.contours_},
        trace_{visibility, arena, from.trace_},
        filter_attributes_{visibility, arena, from.filter_attributes_},
        recostings_{visibility, arena, from.recostings_},
        exclude_polygons_{visibility, arena, from.exclude_polygons_},
        expansion_properties_{visibility, arena, from.expansion_properties_},
        _expansion_properties_cached_byte_size_{0},
        has_language_{},
        has_id_{},
        has_jsonp_{},
        has_encoded_polyline_{},
        has_range_{},
        has_verbose_{},
        has_date_time_{},
        has_resample_distance_{},
        has_polygons_{},
        has_denoise_{},
        has_generalize_{},
        has_show_locations_{},
        has_gps_accuracy_{},
        has_search_radius_{},
        has_turn_penalty_factor_{},
        has_breakage_distance_{},
        has_use_timestamps_{},
        has_alternates_{},
        has_interpolation_distance_{},
        has_guidance_views_{},
        has_height_precision_{},
        has_roundabout_exits_{},
        has_linear_references_{},
        has_prioritize_bidirectional_{},
        has_expansion_action_{},
        has_skip_opposites_{},
        has_matrix_locations_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1], from._oneof_case_[2], from._oneof_case_[3], from._oneof_case_[4], from._oneof_case_[5], from._oneof_case_[6], from._oneof_case_[7], from._oneof_case_[8], from._oneof_case_[9], from._oneof_case_[10], from._oneof_case_[11], from._oneof_case_[12], from._oneof_case_[13], from._oneof_case_[14], from._oneof_case_[15], from._oneof_case_[16], from._oneof_case_[17], from._oneof_case_[18], from._oneof_case_[19], from._oneof_case_[20], from._oneof_case_[21], from._oneof_case_[22], from._oneof_case_[23], from._oneof_case_[24], from._oneof_case_[25], from._oneof_case_[26]} {}

Options::Options(
    ::google::protobuf::Arena* arena,
    const Options& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Options* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.pbf_field_selector_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::PbfFieldSelector>(
                              arena, *from._impl_.pbf_field_selector_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, units_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, units_),
           offsetof(Impl_, reverse_) -
               offsetof(Impl_, units_) +
               sizeof(Impl_::reverse_));
  switch (has_language_case()) {
    case HAS_LANGUAGE_NOT_SET:
      break;
      case kLanguage:
        new (&_impl_.has_language_.language_) decltype(_impl_.has_language_.language_){arena, from._impl_.has_language_.language_};
        break;
  }
  switch (has_id_case()) {
    case HAS_ID_NOT_SET:
      break;
      case kId:
        new (&_impl_.has_id_.id_) decltype(_impl_.has_id_.id_){arena, from._impl_.has_id_.id_};
        break;
  }
  switch (has_jsonp_case()) {
    case HAS_JSONP_NOT_SET:
      break;
      case kJsonp:
        new (&_impl_.has_jsonp_.jsonp_) decltype(_impl_.has_jsonp_.jsonp_){arena, from._impl_.has_jsonp_.jsonp_};
        break;
  }
  switch (has_encoded_polyline_case()) {
    case HAS_ENCODED_POLYLINE_NOT_SET:
      break;
      case kEncodedPolyline:
        new (&_impl_.has_encoded_polyline_.encoded_polyline_) decltype(_impl_.has_encoded_polyline_.encoded_polyline_){arena, from._impl_.has_encoded_polyline_.encoded_polyline_};
        break;
  }
  switch (has_range_case()) {
    case HAS_RANGE_NOT_SET:
      break;
      case kRange:
        _impl_.has_range_.range_ = from._impl_.has_range_.range_;
        break;
  }
  switch (has_verbose_case()) {
    case HAS_VERBOSE_NOT_SET:
      break;
      case kVerbose:
        _impl_.has_verbose_.verbose_ = from._impl_.has_verbose_.verbose_;
        break;
  }
  switch (has_date_time_case()) {
    case HAS_DATE_TIME_NOT_SET:
      break;
      case kDateTime:
        new (&_impl_.has_date_time_.date_time_) decltype(_impl_.has_date_time_.date_time_){arena, from._impl_.has_date_time_.date_time_};
        break;
  }
  switch (has_resample_distance_case()) {
    case HAS_RESAMPLE_DISTANCE_NOT_SET:
      break;
      case kResampleDistance:
        _impl_.has_resample_distance_.resample_distance_ = from._impl_.has_resample_distance_.resample_distance_;
        break;
  }
  switch (has_polygons_case()) {
    case HAS_POLYGONS_NOT_SET:
      break;
      case kPolygons:
        _impl_.has_polygons_.polygons_ = from._impl_.has_polygons_.polygons_;
        break;
  }
  switch (has_denoise_case()) {
    case HAS_DENOISE_NOT_SET:
      break;
      case kDenoise:
        _impl_.has_denoise_.denoise_ = from._impl_.has_denoise_.denoise_;
        break;
  }
  switch (has_generalize_case()) {
    case HAS_GENERALIZE_NOT_SET:
      break;
      case kGeneralize:
        _impl_.has_generalize_.generalize_ = from._impl_.has_generalize_.generalize_;
        break;
  }
  switch (has_show_locations_case()) {
    case HAS_SHOW_LOCATIONS_NOT_SET:
      break;
      case kShowLocations:
        _impl_.has_show_locations_.show_locations_ = from._impl_.has_show_locations_.show_locations_;
        break;
  }
  switch (has_gps_accuracy_case()) {
    case HAS_GPS_ACCURACY_NOT_SET:
      break;
      case kGpsAccuracy:
        _impl_.has_gps_accuracy_.gps_accuracy_ = from._impl_.has_gps_accuracy_.gps_accuracy_;
        break;
  }
  switch (has_search_radius_case()) {
    case HAS_SEARCH_RADIUS_NOT_SET:
      break;
      case kSearchRadius:
        _impl_.has_search_radius_.search_radius_ = from._impl_.has_search_radius_.search_radius_;
        break;
  }
  switch (has_turn_penalty_factor_case()) {
    case HAS_TURN_PENALTY_FACTOR_NOT_SET:
      break;
      case kTurnPenaltyFactor:
        _impl_.has_turn_penalty_factor_.turn_penalty_factor_ = from._impl_.has_turn_penalty_factor_.turn_penalty_factor_;
        break;
  }
  switch (has_breakage_distance_case()) {
    case HAS_BREAKAGE_DISTANCE_NOT_SET:
      break;
      case kBreakageDistance:
        _impl_.has_breakage_distance_.breakage_distance_ = from._impl_.has_breakage_distance_.breakage_distance_;
        break;
  }
  switch (has_use_timestamps_case()) {
    case HAS_USE_TIMESTAMPS_NOT_SET:
      break;
      case kUseTimestamps:
        _impl_.has_use_timestamps_.use_timestamps_ = from._impl_.has_use_timestamps_.use_timestamps_;
        break;
  }
  switch (has_alternates_case()) {
    case HAS_ALTERNATES_NOT_SET:
      break;
      case kAlternates:
        _impl_.has_alternates_.alternates_ = from._impl_.has_alternates_.alternates_;
        break;
  }
  switch (has_interpolation_distance_case()) {
    case HAS_INTERPOLATION_DISTANCE_NOT_SET:
      break;
      case kInterpolationDistance:
        _impl_.has_interpolation_distance_.interpolation_distance_ = from._impl_.has_interpolation_distance_.interpolation_distance_;
        break;
  }
  switch (has_guidance_views_case()) {
    case HAS_GUIDANCE_VIEWS_NOT_SET:
      break;
      case kGuidanceViews:
        _impl_.has_guidance_views_.guidance_views_ = from._impl_.has_guidance_views_.guidance_views_;
        break;
  }
  switch (has_height_precision_case()) {
    case HAS_HEIGHT_PRECISION_NOT_SET:
      break;
      case kHeightPrecision:
        _impl_.has_height_precision_.height_precision_ = from._impl_.has_height_precision_.height_precision_;
        break;
  }
  switch (has_roundabout_exits_case()) {
    case HAS_ROUNDABOUT_EXITS_NOT_SET:
      break;
      case kRoundaboutExits:
        _impl_.has_roundabout_exits_.roundabout_exits_ = from._impl_.has_roundabout_exits_.roundabout_exits_;
        break;
  }
  switch (has_linear_references_case()) {
    case HAS_LINEAR_REFERENCES_NOT_SET:
      break;
      case kLinearReferences:
        _impl_.has_linear_references_.linear_references_ = from._impl_.has_linear_references_.linear_references_;
        break;
  }
  switch (has_prioritize_bidirectional_case()) {
    case HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET:
      break;
      case kPrioritizeBidirectional:
        _impl_.has_prioritize_bidirectional_.prioritize_bidirectional_ = from._impl_.has_prioritize_bidirectional_.prioritize_bidirectional_;
        break;
  }
  switch (has_expansion_action_case()) {
    case HAS_EXPANSION_ACTION_NOT_SET:
      break;
      case kExpansionAction:
        _impl_.has_expansion_action_.expansion_action_ = from._impl_.has_expansion_action_.expansion_action_;
        break;
  }
  switch (has_skip_opposites_case()) {
    case HAS_SKIP_OPPOSITES_NOT_SET:
      break;
      case kSkipOpposites:
        _impl_.has_skip_opposites_.skip_opposites_ = from._impl_.has_skip_opposites_.skip_opposites_;
        break;
  }
  switch (has_matrix_locations_case()) {
    case HAS_MATRIX_LOCATIONS_NOT_SET:
      break;
      case kMatrixLocations:
        _impl_.has_matrix_locations_.matrix_locations_ = from._impl_.has_matrix_locations_.matrix_locations_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.Options)
}
inline PROTOBUF_NDEBUG_INLINE Options::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        costings_{visibility, arena},
        locations_{visibility, arena},
        exclude_locations_{visibility, arena},
        sources_{visibility, arena},
        targets_{visibility, arena},
        shape_{visibility, arena},
        contours_{visibility, arena},
        trace_{visibility, arena},
        filter_attributes_{visibility, arena},
        recostings_{visibility, arena},
        exclude_polygons_{visibility, arena},
        expansion_properties_{visibility, arena},
        _expansion_properties_cached_byte_size_{0},
        has_language_{},
        has_id_{},
        has_jsonp_{},
        has_encoded_polyline_{},
        has_range_{},
        has_verbose_{},
        has_date_time_{},
        has_resample_distance_{},
        has_polygons_{},
        has_denoise_{},
        has_generalize_{},
        has_show_locations_{},
        has_gps_accuracy_{},
        has_search_radius_{},
        has_turn_penalty_factor_{},
        has_breakage_distance_{},
        has_use_timestamps_{},
        has_alternates_{},
        has_interpolation_distance_{},
        has_guidance_views_{},
        has_height_precision_{},
        has_roundabout_exits_{},
        has_linear_references_{},
        has_prioritize_bidirectional_{},
        has_expansion_action_{},
        has_skip_opposites_{},
        has_matrix_locations_{},
        _oneof_case_{} {}

inline void Options::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, pbf_field_selector_),
           0,
           offsetof(Impl_, reverse_) -
               offsetof(Impl_, pbf_field_selector_) +
               sizeof(Impl_::reverse_));
}
Options::~Options() {
  // @@protoc_insertion_point(destructor:valhalla.Options)
  SharedDtor(*this);
}
inline void Options::SharedDtor(MessageLite& self) {
  Options& this_ = static_cast<Options&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.pbf_field_selector_;
  if (this_.has_has_language()) {
    this_.clear_has_language();
  }
  if (this_.has_has_id()) {
    this_.clear_has_id();
  }
  if (this_.has_has_jsonp()) {
    this_.clear_has_jsonp();
  }
  if (this_.has_has_encoded_polyline()) {
    this_.clear_has_encoded_polyline();
  }
  if (this_.has_has_range()) {
    this_.clear_has_range();
  }
  if (this_.has_has_verbose()) {
    this_.clear_has_verbose();
  }
  if (this_.has_has_date_time()) {
    this_.clear_has_date_time();
  }
  if (this_.has_has_resample_distance()) {
    this_.clear_has_resample_distance();
  }
  if (this_.has_has_polygons()) {
    this_.clear_has_polygons();
  }
  if (this_.has_has_denoise()) {
    this_.clear_has_denoise();
  }
  if (this_.has_has_generalize()) {
    this_.clear_has_generalize();
  }
  if (this_.has_has_show_locations()) {
    this_.clear_has_show_locations();
  }
  if (this_.has_has_gps_accuracy()) {
    this_.clear_has_gps_accuracy();
  }
  if (this_.has_has_search_radius()) {
    this_.clear_has_search_radius();
  }
  if (this_.has_has_turn_penalty_factor()) {
    this_.clear_has_turn_penalty_factor();
  }
  if (this_.has_has_breakage_distance()) {
    this_.clear_has_breakage_distance();
  }
  if (this_.has_has_use_timestamps()) {
    this_.clear_has_use_timestamps();
  }
  if (this_.has_has_alternates()) {
    this_.clear_has_alternates();
  }
  if (this_.has_has_interpolation_distance()) {
    this_.clear_has_interpolation_distance();
  }
  if (this_.has_has_guidance_views()) {
    this_.clear_has_guidance_views();
  }
  if (this_.has_has_height_precision()) {
    this_.clear_has_height_precision();
  }
  if (this_.has_has_roundabout_exits()) {
    this_.clear_has_roundabout_exits();
  }
  if (this_.has_has_linear_references()) {
    this_.clear_has_linear_references();
  }
  if (this_.has_has_prioritize_bidirectional()) {
    this_.clear_has_prioritize_bidirectional();
  }
  if (this_.has_has_expansion_action()) {
    this_.clear_has_expansion_action();
  }
  if (this_.has_has_skip_opposites()) {
    this_.clear_has_skip_opposites();
  }
  if (this_.has_has_matrix_locations()) {
    this_.clear_has_matrix_locations();
  }
  this_._impl_.~Impl_();
}

void Options::clear_has_language() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_language_case()) {
    case kLanguage: {
      _impl_.has_language_.language_.Destroy();
      break;
    }
    case HAS_LANGUAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_LANGUAGE_NOT_SET;
}

void Options::clear_has_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_id_case()) {
    case kId: {
      _impl_.has_id_.id_.Destroy();
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_ID_NOT_SET;
}

void Options::clear_has_jsonp() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_jsonp_case()) {
    case kJsonp: {
      _impl_.has_jsonp_.jsonp_.Destroy();
      break;
    }
    case HAS_JSONP_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_JSONP_NOT_SET;
}

void Options::clear_has_encoded_polyline() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_encoded_polyline_case()) {
    case kEncodedPolyline: {
      _impl_.has_encoded_polyline_.encoded_polyline_.Destroy();
      break;
    }
    case HAS_ENCODED_POLYLINE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_ENCODED_POLYLINE_NOT_SET;
}

void Options::clear_has_range() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_range_case()) {
    case kRange: {
      // No need to clear
      break;
    }
    case HAS_RANGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = HAS_RANGE_NOT_SET;
}

void Options::clear_has_verbose() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_verbose_case()) {
    case kVerbose: {
      // No need to clear
      break;
    }
    case HAS_VERBOSE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[5] = HAS_VERBOSE_NOT_SET;
}

void Options::clear_has_date_time() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_date_time_case()) {
    case kDateTime: {
      _impl_.has_date_time_.date_time_.Destroy();
      break;
    }
    case HAS_DATE_TIME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[6] = HAS_DATE_TIME_NOT_SET;
}

void Options::clear_has_resample_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_resample_distance_case()) {
    case kResampleDistance: {
      // No need to clear
      break;
    }
    case HAS_RESAMPLE_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[7] = HAS_RESAMPLE_DISTANCE_NOT_SET;
}

void Options::clear_has_polygons() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_polygons_case()) {
    case kPolygons: {
      // No need to clear
      break;
    }
    case HAS_POLYGONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[8] = HAS_POLYGONS_NOT_SET;
}

void Options::clear_has_denoise() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_denoise_case()) {
    case kDenoise: {
      // No need to clear
      break;
    }
    case HAS_DENOISE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[9] = HAS_DENOISE_NOT_SET;
}

void Options::clear_has_generalize() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_generalize_case()) {
    case kGeneralize: {
      // No need to clear
      break;
    }
    case HAS_GENERALIZE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[10] = HAS_GENERALIZE_NOT_SET;
}

void Options::clear_has_show_locations() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_show_locations_case()) {
    case kShowLocations: {
      // No need to clear
      break;
    }
    case HAS_SHOW_LOCATIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[11] = HAS_SHOW_LOCATIONS_NOT_SET;
}

void Options::clear_has_gps_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_gps_accuracy_case()) {
    case kGpsAccuracy: {
      // No need to clear
      break;
    }
    case HAS_GPS_ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[12] = HAS_GPS_ACCURACY_NOT_SET;
}

void Options::clear_has_search_radius() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_search_radius_case()) {
    case kSearchRadius: {
      // No need to clear
      break;
    }
    case HAS_SEARCH_RADIUS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[13] = HAS_SEARCH_RADIUS_NOT_SET;
}

void Options::clear_has_turn_penalty_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_turn_penalty_factor_case()) {
    case kTurnPenaltyFactor: {
      // No need to clear
      break;
    }
    case HAS_TURN_PENALTY_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[14] = HAS_TURN_PENALTY_FACTOR_NOT_SET;
}

void Options::clear_has_breakage_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_breakage_distance_case()) {
    case kBreakageDistance: {
      // No need to clear
      break;
    }
    case HAS_BREAKAGE_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[15] = HAS_BREAKAGE_DISTANCE_NOT_SET;
}

void Options::clear_has_use_timestamps() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_use_timestamps_case()) {
    case kUseTimestamps: {
      // No need to clear
      break;
    }
    case HAS_USE_TIMESTAMPS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[16] = HAS_USE_TIMESTAMPS_NOT_SET;
}

void Options::clear_has_alternates() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_alternates_case()) {
    case kAlternates: {
      // No need to clear
      break;
    }
    case HAS_ALTERNATES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[17] = HAS_ALTERNATES_NOT_SET;
}

void Options::clear_has_interpolation_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_interpolation_distance_case()) {
    case kInterpolationDistance: {
      // No need to clear
      break;
    }
    case HAS_INTERPOLATION_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[18] = HAS_INTERPOLATION_DISTANCE_NOT_SET;
}

void Options::clear_has_guidance_views() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_guidance_views_case()) {
    case kGuidanceViews: {
      // No need to clear
      break;
    }
    case HAS_GUIDANCE_VIEWS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[19] = HAS_GUIDANCE_VIEWS_NOT_SET;
}

void Options::clear_has_height_precision() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_height_precision_case()) {
    case kHeightPrecision: {
      // No need to clear
      break;
    }
    case HAS_HEIGHT_PRECISION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[20] = HAS_HEIGHT_PRECISION_NOT_SET;
}

void Options::clear_has_roundabout_exits() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_roundabout_exits_case()) {
    case kRoundaboutExits: {
      // No need to clear
      break;
    }
    case HAS_ROUNDABOUT_EXITS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[21] = HAS_ROUNDABOUT_EXITS_NOT_SET;
}

void Options::clear_has_linear_references() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_linear_references_case()) {
    case kLinearReferences: {
      // No need to clear
      break;
    }
    case HAS_LINEAR_REFERENCES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[22] = HAS_LINEAR_REFERENCES_NOT_SET;
}

void Options::clear_has_prioritize_bidirectional() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_prioritize_bidirectional_case()) {
    case kPrioritizeBidirectional: {
      // No need to clear
      break;
    }
    case HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[23] = HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET;
}

void Options::clear_has_expansion_action() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_expansion_action_case()) {
    case kExpansionAction: {
      // No need to clear
      break;
    }
    case HAS_EXPANSION_ACTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[24] = HAS_EXPANSION_ACTION_NOT_SET;
}

void Options::clear_has_skip_opposites() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_skip_opposites_case()) {
    case kSkipOpposites: {
      // No need to clear
      break;
    }
    case HAS_SKIP_OPPOSITES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[25] = HAS_SKIP_OPPOSITES_NOT_SET;
}

void Options::clear_has_matrix_locations() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_matrix_locations_case()) {
    case kMatrixLocations: {
      // No need to clear
      break;
    }
    case HAS_MATRIX_LOCATIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[26] = HAS_MATRIX_LOCATIONS_NOT_SET;
}


inline void* Options::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Options(arena);
}
constexpr auto Options::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Options, _impl_.costings_) +
          decltype(Options::_impl_.costings_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.locations_) +
          decltype(Options::_impl_.locations_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.exclude_locations_) +
          decltype(Options::_impl_.exclude_locations_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.sources_) +
          decltype(Options::_impl_.sources_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.targets_) +
          decltype(Options::_impl_.targets_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.shape_) +
          decltype(Options::_impl_.shape_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.contours_) +
          decltype(Options::_impl_.contours_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.trace_) +
          decltype(Options::_impl_.trace_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.filter_attributes_) +
          decltype(Options::_impl_.filter_attributes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.recostings_) +
          decltype(Options::_impl_.recostings_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.exclude_polygons_) +
          decltype(Options::_impl_.exclude_polygons_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Options, _impl_.expansion_properties_) +
          decltype(Options::_impl_.expansion_properties_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(Options), alignof(Options), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Options::PlacementNew_,
                                 sizeof(Options),
                                 alignof(Options));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<17> Options::_class_data_ = {
    {
        &_Options_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Options::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Options>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Options::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Options>(), &Options::ByteSizeLong,
            &Options::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Options, _impl_._cached_size_),
        true,
    },
    "valhalla.Options",
};
const ::google::protobuf::internal::ClassData* Options::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 50, 12, 130, 9> Options::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Options, _impl_._has_bits_),
    0, // no _extensions_
    54, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    268435712,  // skipmap
    offsetof(decltype(_table_), field_entries),
    50,  // num_field_entries
    12,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Options>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.Options.Units units = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.units_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.DirectionsType directions_type = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.directions_type_)}},
    // .valhalla.Options.Format format = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.format_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.Options.Action action = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.action_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.Costing.Type costing_type = 12;
    {::_pbi::TcParser::FastV32S1,
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.costing_type_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .valhalla.Location locations = 14;
    {::_pbi::TcParser::FastMtR1,
     {114, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.locations_)}},
    // repeated .valhalla.Location exclude_locations = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 1, PROTOBUF_FIELD_OFFSET(Options, _impl_.exclude_locations_)}},
    // repeated .valhalla.Location sources = 16;
    {::_pbi::TcParser::FastMtR2,
     {386, 63, 2, PROTOBUF_FIELD_OFFSET(Options, _impl_.sources_)}},
    // repeated .valhalla.Location targets = 17;
    {::_pbi::TcParser::FastMtR2,
     {394, 63, 3, PROTOBUF_FIELD_OFFSET(Options, _impl_.targets_)}},
    // .valhalla.Options.DateTimeType date_time_type = 18;
    {::_pbi::TcParser::FastV32S2,
     {400, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.date_time_type_)}},
    // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
    {::_pbi::TcParser::FastV32P2,
     {922, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.expansion_properties_)}},
    // repeated .valhalla.Location shape = 20;
    {::_pbi::TcParser::FastMtR2,
     {418, 63, 4, PROTOBUF_FIELD_OFFSET(Options, _impl_.shape_)}},
    // bool reverse = 53;
    {::_pbi::TcParser::FastV8S2,
     {936, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.reverse_)}},
    // repeated .valhalla.Contour contours = 22;
    {::_pbi::TcParser::FastMtR2,
     {434, 63, 5, PROTOBUF_FIELD_OFFSET(Options, _impl_.contours_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .valhalla.Location trace = 27;
    {::_pbi::TcParser::FastMtR2,
     {474, 63, 6, PROTOBUF_FIELD_OFFSET(Options, _impl_.trace_)}},
    // .valhalla.ShapeMatch shape_match = 28;
    {::_pbi::TcParser::FastV32S2,
     {480, 63, 0, PROTOBUF_FIELD_OFFSET(Options, _impl_.shape_match_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .valhalla.Costing recostings = 46;
    {::_pbi::TcParser::FastMtR2,
     {754, 63, 7, PROTOBUF_FIELD_OFFSET(Options, _impl_.recostings_)}},
    // repeated .valhalla.Ring exclude_polygons = 47;
    {::_pbi::TcParser::FastMtR2,
     {762, 63, 8, PROTOBUF_FIELD_OFFSET(Options, _impl_.exclude_polygons_)}},
  }}, {{
    33, 0, 2,
    516, 30, 65472, 44,
    65535, 65535
  }}, {{
    // .valhalla.Options.Units units = 1;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.units_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string language = 2;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_language_.language_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.DirectionsType directions_type = 3;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.directions_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.Options.Format format = 4;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.format_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string id = 5;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_id_.id_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string jsonp = 6;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_jsonp_.jsonp_), _Internal::kOneofCaseOffset + 8, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string encoded_polyline = 7;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_encoded_polyline_.encoded_polyline_), _Internal::kOneofCaseOffset + 12, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.Options.Action action = 8;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.action_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool range = 10;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_range_.range_), _Internal::kOneofCaseOffset + 16, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool verbose = 11;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_verbose_.verbose_), _Internal::kOneofCaseOffset + 20, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // .valhalla.Costing.Type costing_type = 12;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.costing_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // map<int32, .valhalla.Costing> costings = 13;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.costings_), -1, 10,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // repeated .valhalla.Location locations = 14;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.locations_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.Location exclude_locations = 15;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.exclude_locations_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.Location sources = 16;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.sources_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.Location targets = 17;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.targets_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.Options.DateTimeType date_time_type = 18;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.date_time_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string date_time = 19;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_date_time_.date_time_), _Internal::kOneofCaseOffset + 24, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .valhalla.Location shape = 20;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.shape_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // double resample_distance = 21;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_resample_distance_.resample_distance_), _Internal::kOneofCaseOffset + 28, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // repeated .valhalla.Contour contours = 22;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.contours_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool polygons = 23;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_polygons_.polygons_), _Internal::kOneofCaseOffset + 32, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // float denoise = 24;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_denoise_.denoise_), _Internal::kOneofCaseOffset + 36, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float generalize = 25;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_generalize_.generalize_), _Internal::kOneofCaseOffset + 40, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // bool show_locations = 26;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_show_locations_.show_locations_), _Internal::kOneofCaseOffset + 44, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // repeated .valhalla.Location trace = 27;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.trace_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.ShapeMatch shape_match = 28;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.shape_match_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // float gps_accuracy = 30;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_gps_accuracy_.gps_accuracy_), _Internal::kOneofCaseOffset + 48, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float search_radius = 31;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_search_radius_.search_radius_), _Internal::kOneofCaseOffset + 52, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float turn_penalty_factor = 32;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_turn_penalty_factor_.turn_penalty_factor_), _Internal::kOneofCaseOffset + 56, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // .valhalla.FilterAction filter_action = 33;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.filter_action_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // repeated string filter_attributes = 34;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.filter_attributes_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // float breakage_distance = 36;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_breakage_distance_.breakage_distance_), _Internal::kOneofCaseOffset + 60, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // bool use_timestamps = 37;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_use_timestamps_.use_timestamps_), _Internal::kOneofCaseOffset + 64, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // .valhalla.ShapeFormat shape_format = 38;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.shape_format_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 alternates = 39;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_alternates_.alternates_), _Internal::kOneofCaseOffset + 68, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // float interpolation_distance = 40;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_interpolation_distance_.interpolation_distance_), _Internal::kOneofCaseOffset + 72, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // bool guidance_views = 41;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_guidance_views_.guidance_views_), _Internal::kOneofCaseOffset + 76, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // uint32 height_precision = 43;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_height_precision_.height_precision_), _Internal::kOneofCaseOffset + 80, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // bool roundabout_exits = 44;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_roundabout_exits_.roundabout_exits_), _Internal::kOneofCaseOffset + 84, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool linear_references = 45;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_linear_references_.linear_references_), _Internal::kOneofCaseOffset + 88, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // repeated .valhalla.Costing recostings = 46;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.recostings_), -1, 7,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.Ring exclude_polygons = 47;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.exclude_polygons_), -1, 8,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool prioritize_bidirectional = 48;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_prioritize_bidirectional_.prioritize_bidirectional_), _Internal::kOneofCaseOffset + 92, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // .valhalla.Options.Action expansion_action = 49;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_expansion_action_.expansion_action_), _Internal::kOneofCaseOffset + 96, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // bool skip_opposites = 50;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_skip_opposites_.skip_opposites_), _Internal::kOneofCaseOffset + 100, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.expansion_properties_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // .valhalla.PbfFieldSelector pbf_field_selector = 52;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.pbf_field_selector_), _Internal::kHasBitsOffset + 0, 9,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool reverse = 53;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.reverse_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // uint32 matrix_locations = 54;
    {PROTOBUF_FIELD_OFFSET(Options, _impl_.has_matrix_locations_.matrix_locations_), _Internal::kOneofCaseOffset + 104, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::Location>()},
    {::_pbi::TcParser::GetTable<::valhalla::Location>()},
    {::_pbi::TcParser::GetTable<::valhalla::Location>()},
    {::_pbi::TcParser::GetTable<::valhalla::Location>()},
    {::_pbi::TcParser::GetTable<::valhalla::Location>()},
    {::_pbi::TcParser::GetTable<::valhalla::Contour>()},
    {::_pbi::TcParser::GetTable<::valhalla::Location>()},
    {::_pbi::TcParser::GetTable<::valhalla::Costing>()},
    {::_pbi::TcParser::GetTable<::valhalla::Ring>()},
    {::_pbi::TcParser::GetTable<::valhalla::PbfFieldSelector>()},
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(Options()._impl_.costings_)>(
        0, 0, 0, 5,
        11)},
    {::_pbi::TcParser::GetTable<::valhalla::Costing>()},
  }}, {{
    "\20\0\10\0\0\2\5\20\0\0\0\0\0\0\0\0\0\0\11\0\0\0\0\0\0\0\0\0\0\0\0\0\21\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "valhalla.Options"
    "language"
    "id"
    "jsonp"
    "encoded_polyline"
    "date_time"
    "filter_attributes"
  }},
};

PROTOBUF_NOINLINE void Options::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.costings_.Clear();
  _impl_.locations_.Clear();
  _impl_.exclude_locations_.Clear();
  _impl_.sources_.Clear();
  _impl_.targets_.Clear();
  _impl_.shape_.Clear();
  _impl_.contours_.Clear();
  _impl_.trace_.Clear();
  _impl_.filter_attributes_.Clear();
  _impl_.recostings_.Clear();
  _impl_.exclude_polygons_.Clear();
  _impl_.expansion_properties_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.pbf_field_selector_ != nullptr);
    _impl_.pbf_field_selector_->Clear();
  }
  ::memset(&_impl_.units_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.reverse_) -
      reinterpret_cast<char*>(&_impl_.units_)) + sizeof(_impl_.reverse_));
  clear_has_language();
  clear_has_id();
  clear_has_jsonp();
  clear_has_encoded_polyline();
  clear_has_range();
  clear_has_verbose();
  clear_has_date_time();
  clear_has_resample_distance();
  clear_has_polygons();
  clear_has_denoise();
  clear_has_generalize();
  clear_has_show_locations();
  clear_has_gps_accuracy();
  clear_has_search_radius();
  clear_has_turn_penalty_factor();
  clear_has_breakage_distance();
  clear_has_use_timestamps();
  clear_has_alternates();
  clear_has_interpolation_distance();
  clear_has_guidance_views();
  clear_has_height_precision();
  clear_has_roundabout_exits();
  clear_has_linear_references();
  clear_has_prioritize_bidirectional();
  clear_has_expansion_action();
  clear_has_skip_opposites();
  clear_has_matrix_locations();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Options::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Options& this_ = static_cast<const Options&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Options::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Options& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Options)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // .valhalla.Options.Units units = 1;
          if (this_._internal_units() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_units(), target);
          }

          // string language = 2;
          if (this_.has_language_case() == kLanguage) {
            const std::string& _s = this_._internal_language();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Options.language");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // .valhalla.DirectionsType directions_type = 3;
          if (this_._internal_directions_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                3, this_._internal_directions_type(), target);
          }

          // .valhalla.Options.Format format = 4;
          if (this_._internal_format() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_format(), target);
          }

          // string id = 5;
          if (this_.has_id_case() == kId) {
            const std::string& _s = this_._internal_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Options.id");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // string jsonp = 6;
          if (this_.has_jsonp_case() == kJsonp) {
            const std::string& _s = this_._internal_jsonp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Options.jsonp");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // string encoded_polyline = 7;
          if (this_.has_encoded_polyline_case() == kEncodedPolyline) {
            const std::string& _s = this_._internal_encoded_polyline();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Options.encoded_polyline");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          // .valhalla.Options.Action action = 8;
          if (this_._internal_action() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                8, this_._internal_action(), target);
          }

          // bool range = 10;
          if (this_.has_range_case() == kRange) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                10, this_._internal_range(), target);
          }

          // bool verbose = 11;
          if (this_.has_verbose_case() == kVerbose) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                11, this_._internal_verbose(), target);
          }

          // .valhalla.Costing.Type costing_type = 12;
          if (this_._internal_costing_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                12, this_._internal_costing_type(), target);
          }

          // map<int32, .valhalla.Costing> costings = 13;
          if (!this_._internal_costings().empty()) {
            using MapType = ::google::protobuf::Map<::int32_t, ::valhalla::Costing>;
            using WireHelper = _pbi::MapEntryFuncs<::int32_t, ::valhalla::Costing,
                                           _pbi::WireFormatLite::TYPE_INT32,
                                           _pbi::WireFormatLite::TYPE_MESSAGE>;
            const auto& field = this_._internal_costings();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterFlat<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    13, entry.first, entry.second, target, stream);
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    13, entry.first, entry.second, target, stream);
              }
            }
          }

          // repeated .valhalla.Location locations = 14;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_locations_size());
               i < n; i++) {
            const auto& repfield = this_._internal_locations().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    14, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.Location exclude_locations = 15;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_exclude_locations_size());
               i < n; i++) {
            const auto& repfield = this_._internal_exclude_locations().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    15, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.Location sources = 16;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_sources_size());
               i < n; i++) {
            const auto& repfield = this_._internal_sources().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    16, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.Location targets = 17;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_targets_size());
               i < n; i++) {
            const auto& repfield = this_._internal_targets().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    17, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // .valhalla.Options.DateTimeType date_time_type = 18;
          if (this_._internal_date_time_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                18, this_._internal_date_time_type(), target);
          }

          // string date_time = 19;
          if (this_.has_date_time_case() == kDateTime) {
            const std::string& _s = this_._internal_date_time();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Options.date_time");
            target = stream->WriteStringMaybeAliased(19, _s, target);
          }

          // repeated .valhalla.Location shape = 20;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_shape_size());
               i < n; i++) {
            const auto& repfield = this_._internal_shape().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    20, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // double resample_distance = 21;
          if (this_.has_resample_distance_case() == kResampleDistance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                21, this_._internal_resample_distance(), target);
          }

          // repeated .valhalla.Contour contours = 22;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_contours_size());
               i < n; i++) {
            const auto& repfield = this_._internal_contours().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    22, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // bool polygons = 23;
          if (this_.has_polygons_case() == kPolygons) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                23, this_._internal_polygons(), target);
          }

          // float denoise = 24;
          if (this_.has_denoise_case() == kDenoise) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                24, this_._internal_denoise(), target);
          }

          // float generalize = 25;
          if (this_.has_generalize_case() == kGeneralize) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                25, this_._internal_generalize(), target);
          }

          // bool show_locations = 26;
          if (this_.has_show_locations_case() == kShowLocations) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                26, this_._internal_show_locations(), target);
          }

          // repeated .valhalla.Location trace = 27;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_trace_size());
               i < n; i++) {
            const auto& repfield = this_._internal_trace().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    27, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // .valhalla.ShapeMatch shape_match = 28;
          if (this_._internal_shape_match() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                28, this_._internal_shape_match(), target);
          }

          // float gps_accuracy = 30;
          if (this_.has_gps_accuracy_case() == kGpsAccuracy) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                30, this_._internal_gps_accuracy(), target);
          }

          // float search_radius = 31;
          if (this_.has_search_radius_case() == kSearchRadius) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                31, this_._internal_search_radius(), target);
          }

          // float turn_penalty_factor = 32;
          if (this_.has_turn_penalty_factor_case() == kTurnPenaltyFactor) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                32, this_._internal_turn_penalty_factor(), target);
          }

          // .valhalla.FilterAction filter_action = 33;
          if (this_._internal_filter_action() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                33, this_._internal_filter_action(), target);
          }

          // repeated string filter_attributes = 34;
          for (int i = 0, n = this_._internal_filter_attributes_size(); i < n; ++i) {
            const auto& s = this_._internal_filter_attributes().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Options.filter_attributes");
            target = stream->WriteString(34, s, target);
          }

          // float breakage_distance = 36;
          if (this_.has_breakage_distance_case() == kBreakageDistance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                36, this_._internal_breakage_distance(), target);
          }

          // bool use_timestamps = 37;
          if (this_.has_use_timestamps_case() == kUseTimestamps) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                37, this_._internal_use_timestamps(), target);
          }

          // .valhalla.ShapeFormat shape_format = 38;
          if (this_._internal_shape_format() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                38, this_._internal_shape_format(), target);
          }

          // uint32 alternates = 39;
          if (this_.has_alternates_case() == kAlternates) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                39, this_._internal_alternates(), target);
          }

          // float interpolation_distance = 40;
          if (this_.has_interpolation_distance_case() == kInterpolationDistance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                40, this_._internal_interpolation_distance(), target);
          }

          // bool guidance_views = 41;
          if (this_.has_guidance_views_case() == kGuidanceViews) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                41, this_._internal_guidance_views(), target);
          }

          // uint32 height_precision = 43;
          if (this_.has_height_precision_case() == kHeightPrecision) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                43, this_._internal_height_precision(), target);
          }

          // bool roundabout_exits = 44;
          if (this_.has_roundabout_exits_case() == kRoundaboutExits) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                44, this_._internal_roundabout_exits(), target);
          }

          // bool linear_references = 45;
          if (this_.has_linear_references_case() == kLinearReferences) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                45, this_._internal_linear_references(), target);
          }

          // repeated .valhalla.Costing recostings = 46;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_recostings_size());
               i < n; i++) {
            const auto& repfield = this_._internal_recostings().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    46, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.Ring exclude_polygons = 47;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_exclude_polygons_size());
               i < n; i++) {
            const auto& repfield = this_._internal_exclude_polygons().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    47, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // bool prioritize_bidirectional = 48;
          if (this_.has_prioritize_bidirectional_case() == kPrioritizeBidirectional) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                48, this_._internal_prioritize_bidirectional(), target);
          }

          // .valhalla.Options.Action expansion_action = 49;
          if (this_.has_expansion_action_case() == kExpansionAction) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                49, this_._internal_expansion_action(), target);
          }

          // bool skip_opposites = 50;
          if (this_.has_skip_opposites_case() == kSkipOpposites) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                50, this_._internal_skip_opposites(), target);
          }

          // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
          {
            std::size_t byte_size =
                                              this_._impl_._expansion_properties_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteEnumPacked(
                  51, this_._internal_expansion_properties(), byte_size, target);
            }
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.PbfFieldSelector pbf_field_selector = 52;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                52, *this_._impl_.pbf_field_selector_, this_._impl_.pbf_field_selector_->GetCachedSize(), target,
                stream);
          }

          // bool reverse = 53;
          if (this_._internal_reverse() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                53, this_._internal_reverse(), target);
          }

          // uint32 matrix_locations = 54;
          if (this_.has_matrix_locations_case() == kMatrixLocations) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                54, this_._internal_matrix_locations(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Options)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Options::ByteSizeLong(const MessageLite& base) {
          const Options& this_ = static_cast<const Options&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Options::ByteSizeLong() const {
          const Options& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Options)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // map<int32, .valhalla.Costing> costings = 13;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_costings_size());
              for (const auto& entry : this_._internal_costings()) {
                total_size += _pbi::MapEntryFuncs<::int32_t, ::valhalla::Costing,
                                               _pbi::WireFormatLite::TYPE_INT32,
                                               _pbi::WireFormatLite::TYPE_MESSAGE>::ByteSizeLong(entry.first, entry.second);
              }
            }
            // repeated .valhalla.Location locations = 14;
            {
              total_size += 1UL * this_._internal_locations_size();
              for (const auto& msg : this_._internal_locations()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.Location exclude_locations = 15;
            {
              total_size += 1UL * this_._internal_exclude_locations_size();
              for (const auto& msg : this_._internal_exclude_locations()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.Location sources = 16;
            {
              total_size += 2UL * this_._internal_sources_size();
              for (const auto& msg : this_._internal_sources()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.Location targets = 17;
            {
              total_size += 2UL * this_._internal_targets_size();
              for (const auto& msg : this_._internal_targets()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.Location shape = 20;
            {
              total_size += 2UL * this_._internal_shape_size();
              for (const auto& msg : this_._internal_shape()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.Contour contours = 22;
            {
              total_size += 2UL * this_._internal_contours_size();
              for (const auto& msg : this_._internal_contours()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.Location trace = 27;
            {
              total_size += 2UL * this_._internal_trace_size();
              for (const auto& msg : this_._internal_trace()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated string filter_attributes = 34;
            {
              total_size +=
                  2 * ::google::protobuf::internal::FromIntSize(this_._internal_filter_attributes().size());
              for (int i = 0, n = this_._internal_filter_attributes().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_filter_attributes().Get(i));
              }
            }
            // repeated .valhalla.Costing recostings = 46;
            {
              total_size += 2UL * this_._internal_recostings_size();
              for (const auto& msg : this_._internal_recostings()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.Ring exclude_polygons = 47;
            {
              total_size += 2UL * this_._internal_exclude_polygons_size();
              for (const auto& msg : this_._internal_exclude_polygons()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
            {
              total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
                  this_._internal_expansion_properties(), 2, this_._impl_._expansion_properties_cached_byte_size_);
            }
          }
           {
            // .valhalla.PbfFieldSelector pbf_field_selector = 52;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 2 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pbf_field_selector_);
            }
          }
           {
            // .valhalla.Options.Units units = 1;
            if (this_._internal_units() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_units());
            }
            // .valhalla.DirectionsType directions_type = 3;
            if (this_._internal_directions_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_directions_type());
            }
            // .valhalla.Options.Format format = 4;
            if (this_._internal_format() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_format());
            }
            // .valhalla.Options.Action action = 8;
            if (this_._internal_action() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_action());
            }
            // .valhalla.Costing.Type costing_type = 12;
            if (this_._internal_costing_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_costing_type());
            }
            // .valhalla.Options.DateTimeType date_time_type = 18;
            if (this_._internal_date_time_type() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_date_time_type());
            }
            // .valhalla.ShapeMatch shape_match = 28;
            if (this_._internal_shape_match() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_shape_match());
            }
            // .valhalla.FilterAction filter_action = 33;
            if (this_._internal_filter_action() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_filter_action());
            }
            // .valhalla.ShapeFormat shape_format = 38;
            if (this_._internal_shape_format() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_shape_format());
            }
            // bool reverse = 53;
            if (this_._internal_reverse() != 0) {
              total_size += 3;
            }
          }
          switch (this_.has_language_case()) {
            // string language = 2;
            case kLanguage: {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_language());
              break;
            }
            case HAS_LANGUAGE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_id_case()) {
            // string id = 5;
            case kId: {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_id());
              break;
            }
            case HAS_ID_NOT_SET: {
              break;
            }
          }
          switch (this_.has_jsonp_case()) {
            // string jsonp = 6;
            case kJsonp: {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_jsonp());
              break;
            }
            case HAS_JSONP_NOT_SET: {
              break;
            }
          }
          switch (this_.has_encoded_polyline_case()) {
            // string encoded_polyline = 7;
            case kEncodedPolyline: {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_encoded_polyline());
              break;
            }
            case HAS_ENCODED_POLYLINE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_range_case()) {
            // bool range = 10;
            case kRange: {
              total_size += 2;
              break;
            }
            case HAS_RANGE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_verbose_case()) {
            // bool verbose = 11;
            case kVerbose: {
              total_size += 2;
              break;
            }
            case HAS_VERBOSE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_date_time_case()) {
            // string date_time = 19;
            case kDateTime: {
              total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_date_time());
              break;
            }
            case HAS_DATE_TIME_NOT_SET: {
              break;
            }
          }
          switch (this_.has_resample_distance_case()) {
            // double resample_distance = 21;
            case kResampleDistance: {
              total_size += 10;
              break;
            }
            case HAS_RESAMPLE_DISTANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_polygons_case()) {
            // bool polygons = 23;
            case kPolygons: {
              total_size += 3;
              break;
            }
            case HAS_POLYGONS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_denoise_case()) {
            // float denoise = 24;
            case kDenoise: {
              total_size += 6;
              break;
            }
            case HAS_DENOISE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_generalize_case()) {
            // float generalize = 25;
            case kGeneralize: {
              total_size += 6;
              break;
            }
            case HAS_GENERALIZE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_show_locations_case()) {
            // bool show_locations = 26;
            case kShowLocations: {
              total_size += 3;
              break;
            }
            case HAS_SHOW_LOCATIONS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_gps_accuracy_case()) {
            // float gps_accuracy = 30;
            case kGpsAccuracy: {
              total_size += 6;
              break;
            }
            case HAS_GPS_ACCURACY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_search_radius_case()) {
            // float search_radius = 31;
            case kSearchRadius: {
              total_size += 6;
              break;
            }
            case HAS_SEARCH_RADIUS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_turn_penalty_factor_case()) {
            // float turn_penalty_factor = 32;
            case kTurnPenaltyFactor: {
              total_size += 6;
              break;
            }
            case HAS_TURN_PENALTY_FACTOR_NOT_SET: {
              break;
            }
          }
          switch (this_.has_breakage_distance_case()) {
            // float breakage_distance = 36;
            case kBreakageDistance: {
              total_size += 6;
              break;
            }
            case HAS_BREAKAGE_DISTANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_use_timestamps_case()) {
            // bool use_timestamps = 37;
            case kUseTimestamps: {
              total_size += 3;
              break;
            }
            case HAS_USE_TIMESTAMPS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_alternates_case()) {
            // uint32 alternates = 39;
            case kAlternates: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_alternates());
              break;
            }
            case HAS_ALTERNATES_NOT_SET: {
              break;
            }
          }
          switch (this_.has_interpolation_distance_case()) {
            // float interpolation_distance = 40;
            case kInterpolationDistance: {
              total_size += 6;
              break;
            }
            case HAS_INTERPOLATION_DISTANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_guidance_views_case()) {
            // bool guidance_views = 41;
            case kGuidanceViews: {
              total_size += 3;
              break;
            }
            case HAS_GUIDANCE_VIEWS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_height_precision_case()) {
            // uint32 height_precision = 43;
            case kHeightPrecision: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_height_precision());
              break;
            }
            case HAS_HEIGHT_PRECISION_NOT_SET: {
              break;
            }
          }
          switch (this_.has_roundabout_exits_case()) {
            // bool roundabout_exits = 44;
            case kRoundaboutExits: {
              total_size += 3;
              break;
            }
            case HAS_ROUNDABOUT_EXITS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_linear_references_case()) {
            // bool linear_references = 45;
            case kLinearReferences: {
              total_size += 3;
              break;
            }
            case HAS_LINEAR_REFERENCES_NOT_SET: {
              break;
            }
          }
          switch (this_.has_prioritize_bidirectional_case()) {
            // bool prioritize_bidirectional = 48;
            case kPrioritizeBidirectional: {
              total_size += 3;
              break;
            }
            case HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET: {
              break;
            }
          }
          switch (this_.has_expansion_action_case()) {
            // .valhalla.Options.Action expansion_action = 49;
            case kExpansionAction: {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_expansion_action());
              break;
            }
            case HAS_EXPANSION_ACTION_NOT_SET: {
              break;
            }
          }
          switch (this_.has_skip_opposites_case()) {
            // bool skip_opposites = 50;
            case kSkipOpposites: {
              total_size += 3;
              break;
            }
            case HAS_SKIP_OPPOSITES_NOT_SET: {
              break;
            }
          }
          switch (this_.has_matrix_locations_case()) {
            // uint32 matrix_locations = 54;
            case kMatrixLocations: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_matrix_locations());
              break;
            }
            case HAS_MATRIX_LOCATIONS_NOT_SET: {
              break;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Options::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Options*>(&to_msg);
  auto& from = static_cast<const Options&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Options)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.costings_.MergeFrom(from._impl_.costings_);
  _this->_internal_mutable_locations()->MergeFrom(
      from._internal_locations());
  _this->_internal_mutable_exclude_locations()->MergeFrom(
      from._internal_exclude_locations());
  _this->_internal_mutable_sources()->MergeFrom(
      from._internal_sources());
  _this->_internal_mutable_targets()->MergeFrom(
      from._internal_targets());
  _this->_internal_mutable_shape()->MergeFrom(
      from._internal_shape());
  _this->_internal_mutable_contours()->MergeFrom(
      from._internal_contours());
  _this->_internal_mutable_trace()->MergeFrom(
      from._internal_trace());
  _this->_internal_mutable_filter_attributes()->MergeFrom(from._internal_filter_attributes());
  _this->_internal_mutable_recostings()->MergeFrom(
      from._internal_recostings());
  _this->_internal_mutable_exclude_polygons()->MergeFrom(
      from._internal_exclude_polygons());
  _this->_internal_mutable_expansion_properties()->MergeFrom(from._internal_expansion_properties());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.pbf_field_selector_ != nullptr);
    if (_this->_impl_.pbf_field_selector_ == nullptr) {
      _this->_impl_.pbf_field_selector_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::PbfFieldSelector>(arena, *from._impl_.pbf_field_selector_);
    } else {
      _this->_impl_.pbf_field_selector_->MergeFrom(*from._impl_.pbf_field_selector_);
    }
  }
  if (from._internal_units() != 0) {
    _this->_impl_.units_ = from._impl_.units_;
  }
  if (from._internal_directions_type() != 0) {
    _this->_impl_.directions_type_ = from._impl_.directions_type_;
  }
  if (from._internal_format() != 0) {
    _this->_impl_.format_ = from._impl_.format_;
  }
  if (from._internal_action() != 0) {
    _this->_impl_.action_ = from._impl_.action_;
  }
  if (from._internal_costing_type() != 0) {
    _this->_impl_.costing_type_ = from._impl_.costing_type_;
  }
  if (from._internal_date_time_type() != 0) {
    _this->_impl_.date_time_type_ = from._impl_.date_time_type_;
  }
  if (from._internal_shape_match() != 0) {
    _this->_impl_.shape_match_ = from._impl_.shape_match_;
  }
  if (from._internal_filter_action() != 0) {
    _this->_impl_.filter_action_ = from._impl_.filter_action_;
  }
  if (from._internal_shape_format() != 0) {
    _this->_impl_.shape_format_ = from._impl_.shape_format_;
  }
  if (from._internal_reverse() != 0) {
    _this->_impl_.reverse_ = from._impl_.reverse_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_language();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLanguage: {
        if (oneof_needs_init) {
          _this->_impl_.has_language_.language_.InitDefault();
        }
        _this->_impl_.has_language_.language_.Set(from._internal_language(), arena);
        break;
      }
      case HAS_LANGUAGE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_id();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kId: {
        if (oneof_needs_init) {
          _this->_impl_.has_id_.id_.InitDefault();
        }
        _this->_impl_.has_id_.id_.Set(from._internal_id(), arena);
        break;
      }
      case HAS_ID_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[2]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[2];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_jsonp();
      }
      _this->_impl_._oneof_case_[2] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kJsonp: {
        if (oneof_needs_init) {
          _this->_impl_.has_jsonp_.jsonp_.InitDefault();
        }
        _this->_impl_.has_jsonp_.jsonp_.Set(from._internal_jsonp(), arena);
        break;
      }
      case HAS_JSONP_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[3]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[3];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_encoded_polyline();
      }
      _this->_impl_._oneof_case_[3] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kEncodedPolyline: {
        if (oneof_needs_init) {
          _this->_impl_.has_encoded_polyline_.encoded_polyline_.InitDefault();
        }
        _this->_impl_.has_encoded_polyline_.encoded_polyline_.Set(from._internal_encoded_polyline(), arena);
        break;
      }
      case HAS_ENCODED_POLYLINE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[4]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[4];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_range();
      }
      _this->_impl_._oneof_case_[4] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kRange: {
        _this->_impl_.has_range_.range_ = from._impl_.has_range_.range_;
        break;
      }
      case HAS_RANGE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[5]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[5];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_verbose();
      }
      _this->_impl_._oneof_case_[5] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kVerbose: {
        _this->_impl_.has_verbose_.verbose_ = from._impl_.has_verbose_.verbose_;
        break;
      }
      case HAS_VERBOSE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[6]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[6];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_date_time();
      }
      _this->_impl_._oneof_case_[6] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kDateTime: {
        if (oneof_needs_init) {
          _this->_impl_.has_date_time_.date_time_.InitDefault();
        }
        _this->_impl_.has_date_time_.date_time_.Set(from._internal_date_time(), arena);
        break;
      }
      case HAS_DATE_TIME_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[7]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[7];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_resample_distance();
      }
      _this->_impl_._oneof_case_[7] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kResampleDistance: {
        _this->_impl_.has_resample_distance_.resample_distance_ = from._impl_.has_resample_distance_.resample_distance_;
        break;
      }
      case HAS_RESAMPLE_DISTANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[8]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[8];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_polygons();
      }
      _this->_impl_._oneof_case_[8] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kPolygons: {
        _this->_impl_.has_polygons_.polygons_ = from._impl_.has_polygons_.polygons_;
        break;
      }
      case HAS_POLYGONS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[9]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[9];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_denoise();
      }
      _this->_impl_._oneof_case_[9] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kDenoise: {
        _this->_impl_.has_denoise_.denoise_ = from._impl_.has_denoise_.denoise_;
        break;
      }
      case HAS_DENOISE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[10]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[10];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_generalize();
      }
      _this->_impl_._oneof_case_[10] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGeneralize: {
        _this->_impl_.has_generalize_.generalize_ = from._impl_.has_generalize_.generalize_;
        break;
      }
      case HAS_GENERALIZE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[11]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[11];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_show_locations();
      }
      _this->_impl_._oneof_case_[11] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kShowLocations: {
        _this->_impl_.has_show_locations_.show_locations_ = from._impl_.has_show_locations_.show_locations_;
        break;
      }
      case HAS_SHOW_LOCATIONS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[12]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[12];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_gps_accuracy();
      }
      _this->_impl_._oneof_case_[12] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGpsAccuracy: {
        _this->_impl_.has_gps_accuracy_.gps_accuracy_ = from._impl_.has_gps_accuracy_.gps_accuracy_;
        break;
      }
      case HAS_GPS_ACCURACY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[13]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[13];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_search_radius();
      }
      _this->_impl_._oneof_case_[13] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kSearchRadius: {
        _this->_impl_.has_search_radius_.search_radius_ = from._impl_.has_search_radius_.search_radius_;
        break;
      }
      case HAS_SEARCH_RADIUS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[14]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[14];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_turn_penalty_factor();
      }
      _this->_impl_._oneof_case_[14] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTurnPenaltyFactor: {
        _this->_impl_.has_turn_penalty_factor_.turn_penalty_factor_ = from._impl_.has_turn_penalty_factor_.turn_penalty_factor_;
        break;
      }
      case HAS_TURN_PENALTY_FACTOR_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[15]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[15];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_breakage_distance();
      }
      _this->_impl_._oneof_case_[15] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kBreakageDistance: {
        _this->_impl_.has_breakage_distance_.breakage_distance_ = from._impl_.has_breakage_distance_.breakage_distance_;
        break;
      }
      case HAS_BREAKAGE_DISTANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[16]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[16];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_use_timestamps();
      }
      _this->_impl_._oneof_case_[16] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kUseTimestamps: {
        _this->_impl_.has_use_timestamps_.use_timestamps_ = from._impl_.has_use_timestamps_.use_timestamps_;
        break;
      }
      case HAS_USE_TIMESTAMPS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[17]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[17];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_alternates();
      }
      _this->_impl_._oneof_case_[17] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kAlternates: {
        _this->_impl_.has_alternates_.alternates_ = from._impl_.has_alternates_.alternates_;
        break;
      }
      case HAS_ALTERNATES_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[18]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[18];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_interpolation_distance();
      }
      _this->_impl_._oneof_case_[18] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kInterpolationDistance: {
        _this->_impl_.has_interpolation_distance_.interpolation_distance_ = from._impl_.has_interpolation_distance_.interpolation_distance_;
        break;
      }
      case HAS_INTERPOLATION_DISTANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[19]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[19];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_guidance_views();
      }
      _this->_impl_._oneof_case_[19] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGuidanceViews: {
        _this->_impl_.has_guidance_views_.guidance_views_ = from._impl_.has_guidance_views_.guidance_views_;
        break;
      }
      case HAS_GUIDANCE_VIEWS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[20]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[20];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_height_precision();
      }
      _this->_impl_._oneof_case_[20] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kHeightPrecision: {
        _this->_impl_.has_height_precision_.height_precision_ = from._impl_.has_height_precision_.height_precision_;
        break;
      }
      case HAS_HEIGHT_PRECISION_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[21]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[21];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_roundabout_exits();
      }
      _this->_impl_._oneof_case_[21] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kRoundaboutExits: {
        _this->_impl_.has_roundabout_exits_.roundabout_exits_ = from._impl_.has_roundabout_exits_.roundabout_exits_;
        break;
      }
      case HAS_ROUNDABOUT_EXITS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[22]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[22];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_linear_references();
      }
      _this->_impl_._oneof_case_[22] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLinearReferences: {
        _this->_impl_.has_linear_references_.linear_references_ = from._impl_.has_linear_references_.linear_references_;
        break;
      }
      case HAS_LINEAR_REFERENCES_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[23]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[23];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_prioritize_bidirectional();
      }
      _this->_impl_._oneof_case_[23] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kPrioritizeBidirectional: {
        _this->_impl_.has_prioritize_bidirectional_.prioritize_bidirectional_ = from._impl_.has_prioritize_bidirectional_.prioritize_bidirectional_;
        break;
      }
      case HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[24]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[24];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_expansion_action();
      }
      _this->_impl_._oneof_case_[24] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kExpansionAction: {
        _this->_impl_.has_expansion_action_.expansion_action_ = from._impl_.has_expansion_action_.expansion_action_;
        break;
      }
      case HAS_EXPANSION_ACTION_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[25]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[25];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_skip_opposites();
      }
      _this->_impl_._oneof_case_[25] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kSkipOpposites: {
        _this->_impl_.has_skip_opposites_.skip_opposites_ = from._impl_.has_skip_opposites_.skip_opposites_;
        break;
      }
      case HAS_SKIP_OPPOSITES_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[26]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[26];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_matrix_locations();
      }
      _this->_impl_._oneof_case_[26] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kMatrixLocations: {
        _this->_impl_.has_matrix_locations_.matrix_locations_ = from._impl_.has_matrix_locations_.matrix_locations_;
        break;
      }
      case HAS_MATRIX_LOCATIONS_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Options::CopyFrom(const Options& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Options)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Options::InternalSwap(Options* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.costings_.InternalSwap(&other->_impl_.costings_);
  _impl_.locations_.InternalSwap(&other->_impl_.locations_);
  _impl_.exclude_locations_.InternalSwap(&other->_impl_.exclude_locations_);
  _impl_.sources_.InternalSwap(&other->_impl_.sources_);
  _impl_.targets_.InternalSwap(&other->_impl_.targets_);
  _impl_.shape_.InternalSwap(&other->_impl_.shape_);
  _impl_.contours_.InternalSwap(&other->_impl_.contours_);
  _impl_.trace_.InternalSwap(&other->_impl_.trace_);
  _impl_.filter_attributes_.InternalSwap(&other->_impl_.filter_attributes_);
  _impl_.recostings_.InternalSwap(&other->_impl_.recostings_);
  _impl_.exclude_polygons_.InternalSwap(&other->_impl_.exclude_polygons_);
  _impl_.expansion_properties_.InternalSwap(&other->_impl_.expansion_properties_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Options, _impl_.reverse_)
      + sizeof(Options::_impl_.reverse_)
      - PROTOBUF_FIELD_OFFSET(Options, _impl_.pbf_field_selector_)>(
          reinterpret_cast<char*>(&_impl_.pbf_field_selector_),
          reinterpret_cast<char*>(&other->_impl_.pbf_field_selector_));
  swap(_impl_.has_language_, other->_impl_.has_language_);
  swap(_impl_.has_id_, other->_impl_.has_id_);
  swap(_impl_.has_jsonp_, other->_impl_.has_jsonp_);
  swap(_impl_.has_encoded_polyline_, other->_impl_.has_encoded_polyline_);
  swap(_impl_.has_range_, other->_impl_.has_range_);
  swap(_impl_.has_verbose_, other->_impl_.has_verbose_);
  swap(_impl_.has_date_time_, other->_impl_.has_date_time_);
  swap(_impl_.has_resample_distance_, other->_impl_.has_resample_distance_);
  swap(_impl_.has_polygons_, other->_impl_.has_polygons_);
  swap(_impl_.has_denoise_, other->_impl_.has_denoise_);
  swap(_impl_.has_generalize_, other->_impl_.has_generalize_);
  swap(_impl_.has_show_locations_, other->_impl_.has_show_locations_);
  swap(_impl_.has_gps_accuracy_, other->_impl_.has_gps_accuracy_);
  swap(_impl_.has_search_radius_, other->_impl_.has_search_radius_);
  swap(_impl_.has_turn_penalty_factor_, other->_impl_.has_turn_penalty_factor_);
  swap(_impl_.has_breakage_distance_, other->_impl_.has_breakage_distance_);
  swap(_impl_.has_use_timestamps_, other->_impl_.has_use_timestamps_);
  swap(_impl_.has_alternates_, other->_impl_.has_alternates_);
  swap(_impl_.has_interpolation_distance_, other->_impl_.has_interpolation_distance_);
  swap(_impl_.has_guidance_views_, other->_impl_.has_guidance_views_);
  swap(_impl_.has_height_precision_, other->_impl_.has_height_precision_);
  swap(_impl_.has_roundabout_exits_, other->_impl_.has_roundabout_exits_);
  swap(_impl_.has_linear_references_, other->_impl_.has_linear_references_);
  swap(_impl_.has_prioritize_bidirectional_, other->_impl_.has_prioritize_bidirectional_);
  swap(_impl_.has_expansion_action_, other->_impl_.has_expansion_action_);
  swap(_impl_.has_skip_opposites_, other->_impl_.has_skip_opposites_);
  swap(_impl_.has_matrix_locations_, other->_impl_.has_matrix_locations_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
  swap(_impl_._oneof_case_[5], other->_impl_._oneof_case_[5]);
  swap(_impl_._oneof_case_[6], other->_impl_._oneof_case_[6]);
  swap(_impl_._oneof_case_[7], other->_impl_._oneof_case_[7]);
  swap(_impl_._oneof_case_[8], other->_impl_._oneof_case_[8]);
  swap(_impl_._oneof_case_[9], other->_impl_._oneof_case_[9]);
  swap(_impl_._oneof_case_[10], other->_impl_._oneof_case_[10]);
  swap(_impl_._oneof_case_[11], other->_impl_._oneof_case_[11]);
  swap(_impl_._oneof_case_[12], other->_impl_._oneof_case_[12]);
  swap(_impl_._oneof_case_[13], other->_impl_._oneof_case_[13]);
  swap(_impl_._oneof_case_[14], other->_impl_._oneof_case_[14]);
  swap(_impl_._oneof_case_[15], other->_impl_._oneof_case_[15]);
  swap(_impl_._oneof_case_[16], other->_impl_._oneof_case_[16]);
  swap(_impl_._oneof_case_[17], other->_impl_._oneof_case_[17]);
  swap(_impl_._oneof_case_[18], other->_impl_._oneof_case_[18]);
  swap(_impl_._oneof_case_[19], other->_impl_._oneof_case_[19]);
  swap(_impl_._oneof_case_[20], other->_impl_._oneof_case_[20]);
  swap(_impl_._oneof_case_[21], other->_impl_._oneof_case_[21]);
  swap(_impl_._oneof_case_[22], other->_impl_._oneof_case_[22]);
  swap(_impl_._oneof_case_[23], other->_impl_._oneof_case_[23]);
  swap(_impl_._oneof_case_[24], other->_impl_._oneof_case_[24]);
  swap(_impl_._oneof_case_[25], other->_impl_._oneof_case_[25]);
  swap(_impl_._oneof_case_[26], other->_impl_._oneof_case_[26]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
